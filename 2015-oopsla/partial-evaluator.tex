\section{Compile-Time Views for Scala}
\label{sct:interface}

We have implemented \tool, a staging extension for Scala based on compile-time views.It is formally defined in
 \sct{sct:partial-evaluation}, and according to the \calculus calculus (formally defined in \sct{sct:calculus}).
 The staging extension is a compiler plugin that executes in a phase after the
 Scala type checker. The plugin starts with pre-typed Scala programs and uses a
 type annotations~\todo{cite} to track and verify information about the biding-time
 of terms. Currently, it supports only two stages of compilation: host language compile-time
 (types annotated with \code{@ct}) and host language run-time (unannotated code).

To the user, the \tool staging extension exposes a minimal interface (\figref{fig:inter,face}) with
annotations \code{inline} and \code{ct}, and the \code{ct} function.

\begin{figure}
\begin{listing}
package object scalact {

  final class ct extends StaticAnnotation
  final class inline extends StaticAnnotation

  @compileTimeOnly def ct[T](body: => T): T = ???
  @compileTimeOnly def inline[T](body: => T): T = ???

}
\end{listing}
\label{fig:interface}
\caption{Interface of the Scala staging extension.}
\end{figure}

\smartparagraph{Annotation ct} is used at the type level and denotes that one expects a
 compile-time view of a type. The annotation is integrated in the Scala's type system
 and, therefore, can be arbitrarily nested in different variants of types. Table
 \ref{tbl:ct-type} shows how the \code{@ct} annotation can be placed on types
 and how it, due to the translation to the compile-time views (\figref{ct-translation}),
 changes method signatures on annotated types.

\begin{table*}[t]
\caption{Types and corresponding method signatures after the translation to the compile-time view.}
\label{tbl:ct-type}
\centering
\begin{tabularx}{\linewidth}{ X X X X }
\toprule

  Annotated Type              & \ &  Type's Method Signatures                          &  \\
  \code{Int@ct}               & \ &  \code{+(rhs: Int@ct): Int@ct}                     &  \\
  \code{Vector[Int]@ct}       & \ &  \code{map[U](f: (Int => U)@ct): Vector[U]@ct}     &  \\
                              & \ &  \code{length: Int@ct}                             &  \\
  \code{Vector[Int@ct]@ct}    & \ &  \code{map[U](f: (Int@ct => U)@ct): Vector[U]@ct}  &  \\
                              & \ &  \code{length: Int@ct}                             &  \\
  \code{Map[Int@ct, Int]@ct}  & \ &  \code{get(key: Int@ct): Option[Int]@ct}           &  \\

\bottomrule
\end{tabularx}
\end{table*}

 In \tabref{tbl:ct-type}, \code{Int@ct} is a non-polymorphic type and therefore
 according to the translation to the compile-time view (\ref{fig:ct-translation})
 all arguments of all methods will be executed at compile-time. On the other hand,
 \code{Vector[Int]@ct} will have all arguments of all methods transformed except
 the generic ones. In effect, this, makes higher order combinators of \code{Vector}
 operate on dynamic values, thus, function \code{f} passed to \code{map} accepts
 the dynamic value as input. Type \code{Vector[Int@ct]@ct} is has all parts executed
 at compile-time. However, the return type of the function \code{map} can still be
 a compile-time view: due to the type parameter \code{U}.

\smartparagraph{Functions \code{ct} and \code{inline}} are used at the term level
 for promoting Scala objects and functions into their compile-time views. Without
 \code{ct} we would not be able to instantiate compile-time views of the types.
 \tabref{tbl:ct-type} shows how different types of terms are promoted to their
 compile-time views.

\begin{table*}[t]
\caption{Promotion of terms to their compile-time views.}
\label{tbl:ct-type}
\centering
\begin{tabularx}{\linewidth}{ X X }
\toprule

  Promoted Term        \quad \quad \quad & Term's Promoted Type             \\
  \code{ct(Vector)(1, 2, 3)            } & \code{: Vector[Int]@ct        }  \\
  \code{ct(Vector)(ct(1), ct(2), ct(3))} & \code{: Vector[Int@ct]@ct     }  \\
  \code{new (Cons@ct)(1, Nil)          } & \code{: Cons[Int]@ct          }  \\
  \code{new (Cons@ct)(ct(1), ct(Nil))  } & \code{: Cons[Int@ct]@ct       }  \\
  \code{ct((x: Int) => x)              } & \code{: (Int@ct => Int@ct)@ct   }  \\
  \code{inline((x: Int) => x)       } & \code{: (Int => Int)@ct }  \\

\bottomrule
\end{tabularx}
\end{table*}

\todo{footnote about Scala objects}
\todo{static promotion of lambdas}
Function \code{ct} can be applied to objects (\eg \code{Vector}) to provide a compile-time
 view over their methods. When those objects have generic parameters, \code{ct} be used
 to promote the arguments, and thus, the result types of these functions. When applied,
 on functions \code{ct} promotes the compile-time view as well as its arguments
 and the return type. \todo{inline}

\smartparagraph{Annotation inline} can be used only on methods and functions. This function
uses partial evaluation to achieve inlining\todo{cite}. This is not the first time that
inlining is achieved through partial evaluation\todo{cite}, however, partial evaluation is
trivially added to the system. It directly corresponds to adding \code{inline} from
\calculus in front of the function or method definition.

% TODO discuss inline as @ct
% TODO discuss automatic conversions
% TODO discuss more usability things.
