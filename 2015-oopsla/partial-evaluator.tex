\section{Compile-Time Views for Scala}
\label{sct:interface}

% TODO This is all together not good without having @inline at the term level (classes,
% objects, traits, methods, etc.). Unfortunately, this opens up a new can of worms
% that we are not ready for now. If the paper is ready by Tuesday evening we can take a
% stab at it.

% Motivate: data structure that whenever instantiated is already ct.
% Example: complex number, parser ...
% inline on classes and their methods
% inline on traits
% inline and inheritance

We have implemented \tool, a staging extension for Scala based on compile-time views.
 \tool is a compiler plugin that executes in a phase after the
 Scala type checker. The plugin starts with pre-typed Scala programs and uses
 type annotations~\cite{odersky_1996_putting} to track and verify information about the biding-time
 of terms. Currently, it supports only two stages of compilation: host language compile-time
 (types annotated with \code{@ct}) and host language run-time (unannotated code).

To the user, \tool exposes a minimal interface (\figref{fig:interface}) with
annotations \code{inline} and \code{ct}, and functions \code{inline} and \code{ct}.

\begin{figure}
\begin{listing}
package object scalact {

  final class ct extends StaticAnnotation
  final class inline extends StaticAnnotation

  @compileTimeOnly def ct[T](body: => T): T = ???
  @compileTimeOnly def inline[T](body: => T): T = ???

}
\end{listing}
\label{fig:interface}
\caption{Interface of the \tool.}
\end{figure}

\smartparagraph{Annotation \code{ct}} is used at the type level~(\eg,
\code{Int@ct}) and denotes a compile-time view of a type. The
annotation is integrated in the Scala's type system  and, therefore, can be
arbitrarily nested in different variants of types. Table  \ref{tbl:ct-type}
shows how the \code{@ct} annotation can be placed on types and how it, due to
the translation to the compile-time views (\figref{ct-translation}), changes
method signatures on annotated types.

\begin{table*}[t]
\caption{Types and corresponding method signatures after the translation to the compile-time view.}
\label{tbl:ct-type}
\centering
\begin{tabularx}{\linewidth}{ X X X X }
\toprule

  Annotated Type              & \ &  Type's Method Signatures                          &  \\
  \code{Int@ct}               & \ &  \code{+(rhs: Int@ct): Int@ct}                     &  \\
  \code{Vector[Int]@ct}       & \ &  \code{map[U](f: (Int => U)@ct): Vector[U]@ct}     &  \\
                              & \ &  \code{length: Int@ct}                             &  \\
  \code{Vector[Int@ct]@ct}    & \ &  \code{map[U](f: (Int@ct => U)@ct): Vector[U]@ct}  &  \\
                              & \ &  \code{length: Int@ct}                             &  \\
  \code{Map[Int@ct, Int]@ct}  & \ &  \code{get(key: Int@ct): Option[Int]@ct}           &  \\

\bottomrule
\end{tabularx}
\end{table*}

 In \tabref{tbl:ct-type}, \code{Int@ct} is a non-polymorphic type and therefore
 according to the translation to the compile-time view (\ref{fig:ct-translation})
 parameters of all methods will also be compile-time views. On the other hand,
 \code{Vector[Int]@ct} will have parameters of all methods transformed except
 the generic ones. In effect, this, makes higher order combinators of \code{Vector}
 operate on dynamic values, thus, function \code{f} passed to \code{map} accepts
 the dynamic value as input. Type \code{Vector[Int@ct]@ct} has all parts executed
 at compile-time. The return type of the function \code{map} can still be
 both dynamic and a compile-time view: due to the type parameter \code{U}.

\smartparagraph{Annotation inline} can be used only at the term level on statically
 known methods and functions. It denotes that the method/function will be inlined during
 compilation time. In other words, \code{inline} is marking that the function application
 is a compile-time computation and that application should be removed by partial evaluation.
 This is not the first time that inlining is achieved through partial
 evaluation~\cite{monnier2003inlining}.

 Internally \code{inline} can be expressed in terms of the \code{ct} annotation. A method\begin{lstparagraph}
@inline def dot[V: Numeric]
  (v1: Vector[V], v2: Vector[V]): V
\end{lstparagraph}
  will have an internal method type\begin{lstparagraph}
((v1: Vector[V], v2: Vector[V]) => V)@ct
\end{lstparagraph} that can not be written by the users. We choose the name
 \code{inline} to be consistent with the existing Scala \code{inline} annotation.


\smartparagraph{Functions \code{ct} and \code{inline}} are used at the term level
 for promoting Scala objects and methods/functions into their compile-time views. Without the
 the \code{ct} and \code{inline} we would not be able to instantiate compile-time views of types.
 \tabref{tbl:ct-type} shows how different types of terms are promoted to their
 compile-time views.

\begin{table*}[t]
\caption{Promotion of terms to their compile-time views.}
\label{tbl:ct-type}
\centering
\begin{tabularx}{\linewidth}{ X X }
\toprule

  Promoted Term        \quad \quad \quad & Term's Promoted Type             \\
  \code{ct(Vector)(1, 2, 3)            } & \code{: Vector[Int]@ct        }  \\
  \code{ct(Vector)(ct(1), ct(2), ct(3))} & \code{: Vector[Int@ct]@ct     }  \\
  \code{new (Cons@ct)(1, Nil)          } & \code{: Cons[Int]@ct          }  \\
  \code{new (Cons@ct)(ct(1), ct(Nil))  } & \code{: Cons[Int@ct]@ct       }  \\
  \code{ct((x: Int) => x)              } & \code{: (Int@ct => Int@ct)@ct }  \\
  \code{inline((x: Int) => x)          } & \code{: (Int => Int)@ct       }  \\

\bottomrule
\end{tabularx}
\end{table*}

Function \code{ct} can be applied to objects (\eg, \code{Vector}) to provide a compile-time
 view over their methods. When those objects have generic parameters, \code{ct} be used
 to promote the arguments, and thus, the result types of these functions. When applied,
 on functions \code{ct} promotes the compile-time view as well as its arguments
 and the return type.

Function \code{inline} can be applied on functions/methods to promote only the function/method
 to their compile time views without promoting the arguments. This function can be
 seen as a shallow version of \code{ct} that makes only the outer type a compile-time view.

\subsection{Tracking Static Terms}
\label{sct:static}


\subsection{Well-Formedness of Compile-Time Views}
\label{sct:wf-ctv}

% Nice description of csp and pointer to the right paper.
Earlier stages of computation can not depend on values from later stages. This property,
 defined as \emph{cross-stage persistence}~\cite{taha_multi-stage_1997,westbrook2010mint},
 imposes that all operations on compile-time views must known at compile time.

To satisfy cross-stage persistence \tool verifies that composite dynamic
 types~(\eg, polymorphic-types, function types, record types, etc.) are not composed
 of compile-time views. The intuition is that all method parameters~(including \code{this})
 of compile time views must either be a compile-time view or them selves type variables. In the following example,
 we show malformed types and examples of terms that are inconsistent with causality\begin{lstparagraph}
xs: List[Int@ct]     => ct(Predef).println(xs.head)
fn: (Int@ct=>Int@ct) => ct(Predef).println(fn(ct(1)))
\end{lstparagraph}

In the first example the program should print the head of the dynamically known list
 at compile time. In the second example the statement should print the result of \code{fn} at
 compile time but the body of the function is unknown.

% Examples on classes
The \code{inline} annotation promotes only function/method bodies to compile-time views. In effect,
 this requires only the method/function body to be known at compile time. Method bodies
 are statically known in objects and classes with final methods, thus, the \code{inline}
 annotation is only applicable on such methods.

\subsection{Least Upper Bounds}
\label{sct:lub}

\subsection{Convenient Implicit Conversions}
\label{sct:implicits}
