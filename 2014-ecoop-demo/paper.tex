\documentclass{llncs}
\usepackage{llncsdoc}

% Build
\usepackage{subfiles}

% Math
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{math}
\usepackage{mathtools}

% Graphics
\usepackage{graphicx}

% Text stuff
\usepackage{listings}
%% sstucki: comment this back in later. my eyes hurt from the
%% pixelated substituted fonts...
%\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{hyperref}
\usepackage[usenames]{color}
\usepackage[font=bf,labelfont=bf]{caption}
\DeclareCaptionType{copyrightbox}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage{etoolbox}
\usepackage{stmaryrd}

% PL Formulas
\usepackage{fleqn}
\usepackage{latexsym}
\usepackage{bcprules}
\usepackage{prooftree}

\patchcmd{\maketitle}{\@copyrightspace}{}{}{}
%\usepackage[font=bf,labelfont=bf]{caption}

%for Strikethrough, to remove when not required anymore
\usepackage[normalem]{ulem}

% Layout
\usepackage{xspace}% space in macros
\usepackage{multicol}

% Makes tables look beautiful
\usepackage{booktabs}
\usepackage{tabularx}

\input{yy_macros}

% ----- begin macros
\lstdefinelanguage{Scala}%
{morekeywords={abstract,%
  case,catch,char,class,%
  def,else,extends,final,for,%
  if,import,implicit,%
  match,module,%
  new,null,%
  object,override,%
  %package,% commented out for a specific example
  private,protected,public,%
  for,public,return,super,%
  this,throw,trait,try,type,%
  val,var,%
  with,while,%
  yield,%
  macro%
  },%
  sensitive,%
  morecomment=[l]//,%
  morecomment=[s]{/*}{*/},%
  morestring=[b]",%
  morestring=[b]',%
  showstringspaces=false%
}[keywords,comments,strings]%

\lstset{language=Scala,%
  mathescape=true,%
%  columns=[c]fixed,%
%  basewidth={0.5em, 0.40em},%
  aboveskip=1pt,%\smallskipamount,
  belowskip=1pt,%\negsmallskipamount,
  lineskip=-0.2pt,
  basewidth={0.54em, 0.4em},%
%  basicstyle=\ttfamily,%\scriptsize,%
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\sffamily\bfseries%
%  keywordstyle=\sffamily\bfseries,%
%  xleftmargin=0.5cm
}


\newcommand{\commentstyle}[1]{\slseries{#1}}
\newcommand{\keywordstyle}[1]{\bfseries{#1}}

% Code
\lstnewenvironment{listing}{\lstset{language=Scala}}{}
\lstnewenvironment{listingsmall}{\lstset{language=Scala,basicstyle=\small\ttfamily}}{}
\lstnewenvironment{listingtiny}{\lstset{language=Scala,basicstyle=\scriptsize\ttfamily}}{}

\newcommand{\scode}[1]{\lstinline[language=Scala,columns=fixed,basicstyle=\ttfamily,keywordstyle=\ttfamily]|#1|}
\newcommand{\jcode}[1]{\lstinline[language=Java,flexiblecolumns=true,basicstyle=\ttfamily]{#1}}

\newcommand{\code}[1]{\scode{#1}}
\newcommand{\sct}[1]{(\S \ref{#1})}

% TODOs:
\newif\ifshowTodos
\showTodostrue
\showTodosfalse % Uncomment this to hide all TODOs.
\ifshowTodos
\newcommand{\todo}[1]{{\color{red} \textbf{[TODO: #1 ]}}}
\newcommand{\sstucki}[1]{{\color{red} [\textbf{sstucki}: #1 ]}}
\newcommand{\manojo}[1]{{\color{red} [\textbf{manojo}: #1 ]}}
\newcommand{\comm}[1]{}
\newcommand{\orElse}[2]{{\color{red} [\sout{#1} {\color{magenta} #2}]}}
\else
\newcommand{\todo}[1]{}
\newcommand{\sstucki}[1]{}
\newcommand{\manojo}[1]{}
\newcommand{\comm}[1]{}
\newcommand{\orElse}[2]{#2}
\renewcommand{\sout}[1]{}
\fi
% paper specific commands
\newcommand{\tool}{Yin-Yang\xspace}



\begin{document}

\title{Yin-Yang: Concealing the Deep Embedding of DSLs}

\author{Vojin Jovanovic and Amir Shaikhha}

\institute{Ecole Polythechnique Federale de Lausanne, EPFL\\
\email{\{first\}.\{last\}@epfl.ch}}

\maketitle

\begin{abstract}
Deeply embedded domain-specific languages (EDSLs) inherently compromise programmer experience for improved program performance. Shallow EDSLs complement them by trading program performance for good programmer experience. We present Yin-Yang, a framework for DSL embedding that uses Scala reflection to reliably translate shallow EDSL programs to the corresponding deep EDSL programs. The translation allows program prototyping and debugging in the user friendly shallow embedding, while the corresponding deep embedding is used in production\textemdash where performance is important. The reliability of the translation completely conceals the deep embedding from the DSL user. For the DSL author, Yin-Yang generates the deep DSL embeddings from their shallow counterparts by reusing the core translation. This obviates the need for code duplication and assures that the implementations of the two embeddings are always synchronised.
\end{abstract}
% \category{D.3.3}{Programming Languages}{Language Constructs and Features}

\keywords
Embedded Domain-Specific Languages, Macros, Deep Embedding, Shallow Embedding, Compile-Time Meta-Programming

\section{Introduction}

% External DSLs
External Domain-specific languages (DSLs) are languages with a custom compiler specialized to a particular application domain. Knowledge about the domain and language specialization give the compiler possibilities for optimization that do not exist in general purpose languages. The restricted language makes it easy for \emph{DSL users} to learn the language while the optimizations can yield execution times close to hand-optimized programs \cite{rompf_optimizing_2013}.

% Embedded DSLs
Development of external DSLs includes building a parser and type checker as well as a large tool-chain (i.e., debuggers, IDEs, and documentation tools). An appealing alternative are \emph{embedded DSLs}~(EDSLs)~\cite{Hudak96csur} that reuse the parser, type checker and the tool-chain of the general-purpose \emph{host language} to minimize required development effort. We can classify DSL embeddings into two categories:

\begin{itemize}

\item \emph{Shallow embeddings} where values in the embedded language are \emph{directly} represented by the values in the host language. A special sub-category of shallow embeddings are \emph{direct embeddings} where language constructs and term types are exactly the same as in the host language.

\item \emph{Deep embeddings} where values in the embedded language are symbolically (with data structures) represented in the host language.

\end{itemize}




\bibliographystyle{plain}

\bibliography{vjovanov-lib,manual}

\end{document}



