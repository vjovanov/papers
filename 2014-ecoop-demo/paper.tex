\documentclass{llncs}
\usepackage{llncsdoc}

% Build
\usepackage{subfiles}

% Math
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{math}
\usepackage{mathtools}

% Graphics
\usepackage{graphicx}

% Text stuff
\usepackage{listings}
%% sstucki: comment this back in later. my eyes hurt from the
%% pixelated substituted fonts...
%\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{hyperref}
\usepackage[usenames]{color}
\usepackage[font=bf,labelfont=bf]{caption}
\DeclareCaptionType{copyrightbox}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage{etoolbox}
\usepackage{stmaryrd}

% PL Formulas
\usepackage{fleqn}
\usepackage{latexsym}
\usepackage{bcprules}
\usepackage{prooftree}

\patchcmd{\maketitle}{\@copyrightspace}{}{}{}
%\usepackage[font=bf,labelfont=bf]{caption}

%for Strikethrough, to remove when not required anymore
\usepackage[normalem]{ulem}

% Layout
\usepackage{xspace}% space in macros
\usepackage{multicol}

% Makes tables look beautiful
\usepackage{booktabs}
\usepackage{tabularx}

\input{yy_macros}

% ----- begin macros
\lstdefinelanguage{Scala}%
{morekeywords={abstract,%
  case,catch,char,class,%
  def,else,extends,final,for,%
  if,import,implicit,%
  match,module,%
  new,null,%
  object,override,%
  %package,% commented out for a specific example
  private,protected,public,%
  for,public,return,super,%
  this,throw,trait,try,type,%
  val,var,%
  with,while,%
  yield,%
  macro%
  },%
  sensitive,%
  morecomment=[l]//,%
  morecomment=[s]{/*}{*/},%
  morestring=[b]",%
  morestring=[b]',%
  showstringspaces=false%
}[keywords,comments,strings]%

\lstset{language=Scala,%
  mathescape=true,%
%  columns=[c]fixed,%
%  basewidth={0.5em, 0.40em},%
  aboveskip=1pt,%\smallskipamount,
  belowskip=1pt,%\negsmallskipamount,
  lineskip=-0.2pt,
  basewidth={0.54em, 0.4em},%
%  basicstyle=\ttfamily,%\scriptsize,%
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\sffamily\bfseries%
%  keywordstyle=\sffamily\bfseries,%
%  xleftmargin=0.5cm
}


\newcommand{\commentstyle}[1]{\slseries{#1}}
\newcommand{\keywordstyle}[1]{\bfseries{#1}}

% Code
\lstnewenvironment{listing}{\lstset{language=Scala}}{}
\lstnewenvironment{listingsmall}{\lstset{language=Scala,basicstyle=\small\ttfamily}}{}
\lstnewenvironment{listingtiny}{\lstset{language=Scala,basicstyle=\scriptsize\ttfamily}}{}

\newcommand{\scode}[1]{\lstinline[language=Scala,columns=fixed,basicstyle=\ttfamily,keywordstyle=\ttfamily]|#1|}
\newcommand{\jcode}[1]{\lstinline[language=Java,flexiblecolumns=true,basicstyle=\ttfamily]{#1}}

\newcommand{\code}[1]{\scode{#1}}
\newcommand{\sct}[1]{(\S \ref{#1})}

% TODOs:
\newif\ifshowTodos
\showTodostrue
\showTodosfalse % Uncomment this to hide all TODOs.
\ifshowTodos
\newcommand{\todo}[1]{{\color{red} \textbf{[TODO: #1 ]}}}
\newcommand{\sstucki}[1]{{\color{red} [\textbf{sstucki}: #1 ]}}
\newcommand{\manojo}[1]{{\color{red} [\textbf{manojo}: #1 ]}}
\newcommand{\comm}[1]{}
\newcommand{\orElse}[2]{{\color{red} [\sout{#1} {\color{magenta} #2}]}}
\else
\newcommand{\todo}[1]{}
\newcommand{\sstucki}[1]{}
\newcommand{\manojo}[1]{}
\newcommand{\comm}[1]{}
\newcommand{\orElse}[2]{#2}
\renewcommand{\sout}[1]{}
\fi
% paper specific commands
\newcommand{\tool}{Yin-Yang\xspace}



\begin{document}

\title{Yin-Yang: Concealing the Deep Embedding of DSLs}

\author{Vojin Jovanovic and Amir Shaikhha}

\institute{Ecole Polythechnique Federale de Lausanne, EPFL\\
\email{\{first\}.\{last\}@epfl.ch}}

\maketitle

\begin{abstract}
Deeply embedded domain-specific languages (EDSLs) inherently compromise programmer experience for improved program performance. Shallow EDSLs complement them by trading program performance for good programmer experience. We present Yin-Yang, a framework for DSL embedding that uses Scala reflection to reliably translate shallow EDSL programs to the corresponding deep EDSL programs. The translation allows program prototyping and debugging in the user friendly shallow embedding, while the corresponding deep embedding is used in production\textemdash where performance is important. The reliability of the translation completely conceals the deep embedding from the DSL user. For the DSL author, Yin-Yang generates the deep DSL embeddings from their shallow counterparts by reusing the core translation. This obviates the need for code duplication and assures that the implementations of the two embeddings are always synchronised.
\end{abstract}
% \category{D.3.3}{Programming Languages}{Language Constructs and Features}

\keywords
Embedded Domain-Specific Languages, Macros, Deep Embedding, Shallow Embedding, Compile-Time Meta-Programming

\section{Introduction}

% External DSLs
External Domain-specific languages (DSLs) are languages with a custom compiler specialized to a particular application domain. Knowledge about the domain and language specialization give the compiler possibilities for optimization that do not exist in general purpose languages. The restricted language makes it easy for \emph{DSL users} to learn the language while the optimizations can yield execution times close to hand-optimized programs \cite{rompf_optimizing_2013}.

% Embedded DSLs
Development of external DSLs includes building a parser and type checker as well as a large tool-chain (i.e., debuggers, IDEs, and documentation tools). An appealing alternative are \emph{embedded DSLs}~(EDSLs)~\cite{Hudak96csur} that reuse the parser, type checker and the tool-chain of the general-purpose \emph{host language} to minimize required development effort. We can classify DSL embeddings into two categories:

\begin{itemize}

\item \emph{Shallow embeddings} where values in the embedded language are \emph{directly} represented by the values in the host language. A special sub-category of shallow embeddings are \emph{direct embeddings} where language constructs and term types are exactly the same as in the host language.

\item \emph{Deep embeddings} where values in the embedded language are symbolically (with data structures) represented in the host language.

\end{itemize}

Direct embeddings are typically friendly for the \emph{DSL user} as they \emph{i)} \emph{linguistically match} the host language and \emph{ii)} can be easily debugged since values of the embedded language directly correspond to the values of the host language. However, since programs can not be introspected, the number of possible domain-specific optimizations is limited.

% Deep embedding exhibits good performance but interface suffers
Deep embeddings reify the DSL programs into an \emph{intermediate representation} IR. The reification hinders usability as it often relies on complex type system constructs that create a linguistic mismatch with the host language. Furthermore, the IR construction prevents term introspection during debugging and makes the problem even harder. However, the domain knowledge about the IR opens opportunities for optimizations.

% DSL author goes through horror of making the interface usable


% Yin-Yang translates deep embedding into the shallow one

% Generation

\section{Demonstration: A DSL for In-Memory Queries}

  % We generate deep embedding for the shallow embedding
  Our demonstration shows how \tool is used by: \emph{i)} the DSL author and \emph{ii)} the DSL user. The demonstration shows how the DSL user can be agnostic about concept of the deep embedding. Furthermore, the DSL author can program the deep embeddings and program transformations as regular Scala code. For the purpose of the demonstration we use a DSL for writing in-memory queries.

  % We will write operators for the query language in the direct embeddings
  The DSL author writes a na\"{\i}ve Scala implementation of common query operators.

  The DSL user can immediately write concise queries in the DSL. Although the query performance is satisfactory for prototyping, in production, the overhead is unacceptably large.

  % From the direct embedding we will generate the deep embedding
  To improve on the situation the DSL author decides to provide a deep embedding for the query engine. All he needs to do is place a single Scala annotation per query operator he implemented. The annotation marks that the for the operator the author would like to have a deep embedding.

  % The DSL user will write queries.
  All the DSL user needs to do now is put the queries in a DSL scope. After putting queries into the DSL scopes the user is still faced with the same type errors as before. The program execution errors can still be debugged in a standard debugger. After placing queries into scopes all standard compiler optimizations are applied to the DSL yielding significant performance improvements.

  % Demonstrate the type errors, debugging, and prototyping.
  The DSL user then decides to further improve performance by introducing the domain specific optimizations in the query language. The DSL author declares simple rewrite rules that the DSL compiler will later apply. The rewrite rules are specified through Scala quasiquotes and thus the DSL author can stay completely agnostic of the underlying data structures.

  % Example of the rule

  % Performance
  The DSL author then measures performance of his DSL and realizes that the generated code performs on par with the hand-optimized version of the query.

\bibliographystyle{plain}

\bibliography{vjovanov-lib,manual}

\end{document}



