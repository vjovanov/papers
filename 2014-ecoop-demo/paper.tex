\documentclass{llncs}
\usepackage{llncsdoc}

% Build
\usepackage{subfiles}

% Math
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{math}
\usepackage{mathtools}

% Graphics
\usepackage{graphicx}

% Text stuff
\usepackage{listings}
%% sstucki: comment this back in later. my eyes hurt from the
%% pixelated substituted fonts...
%\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{hyperref}
\usepackage[usenames]{color}
\usepackage[font=bf,labelfont=bf]{caption}
\DeclareCaptionType{copyrightbox}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage{etoolbox}
\usepackage{stmaryrd}

% PL Formulas
\usepackage{fleqn}
\usepackage{latexsym}
\usepackage{bcprules}
\usepackage{prooftree}

\patchcmd{\maketitle}{\@copyrightspace}{}{}{}
%\usepackage[font=bf,labelfont=bf]{caption}

%for Strikethrough, to remove when not required anymore
\usepackage[normalem]{ulem}

% Layout
\usepackage{xspace}% space in macros
\usepackage{multicol}

% Makes tables look beautiful
\usepackage{booktabs}
\usepackage{tabularx}

\input{yy_macros}

% ----- begin macros
\lstdefinelanguage{Scala}%
{morekeywords={abstract,%
  case,catch,char,class,%
  def,else,extends,final,for,%
  if,import,implicit,%
  match,module,%
  new,null,%
  object,override,%
  %package,% commented out for a specific example
  private,protected,public,%
  for,public,return,super,%
  this,throw,trait,try,type,%
  val,var,%
  with,while,%
  yield,%
  macro%
  },%
  sensitive,%
  morecomment=[l]//,%
  morecomment=[s]{/*}{*/},%
  morestring=[b]",%
  morestring=[b]',%
  showstringspaces=false%
}[keywords,comments,strings]%

\lstset{language=Scala,%
  mathescape=true,%
%  columns=[c]fixed,%
%  basewidth={0.5em, 0.40em},%
  aboveskip=1pt,%\smallskipamount,
  belowskip=1pt,%\negsmallskipamount,
  lineskip=-0.2pt,
  basewidth={0.54em, 0.4em},%
%  basicstyle=\ttfamily,%\scriptsize,%
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\sffamily\bfseries%
%  keywordstyle=\sffamily\bfseries,%
%  xleftmargin=0.5cm
}


\newcommand{\commentstyle}[1]{\slseries{#1}}
\newcommand{\keywordstyle}[1]{\bfseries{#1}}

% Code
\lstnewenvironment{listing}{\lstset{language=Scala}}{}
\lstnewenvironment{listingsmall}{\lstset{language=Scala,basicstyle=\small\ttfamily}}{}
\lstnewenvironment{listingtiny}{\lstset{language=Scala,basicstyle=\scriptsize\ttfamily}}{}

\newcommand{\scode}[1]{\lstinline[language=Scala,columns=fixed,basicstyle=\ttfamily,keywordstyle=\ttfamily]|#1|}
\newcommand{\jcode}[1]{\lstinline[language=Java,flexiblecolumns=true,basicstyle=\ttfamily]{#1}}

\newcommand{\code}[1]{\scode{#1}}
\newcommand{\sct}[1]{(\S \ref{#1})}

% TODOs:
\newif\ifshowTodos
\showTodostrue
\showTodosfalse % Uncomment this to hide all TODOs.
\ifshowTodos
\newcommand{\todo}[1]{{\color{red} \textbf{[TODO: #1 ]}}}
\newcommand{\sstucki}[1]{{\color{red} [\textbf{sstucki}: #1 ]}}
\newcommand{\manojo}[1]{{\color{red} [\textbf{manojo}: #1 ]}}
\newcommand{\comm}[1]{}
\newcommand{\orElse}[2]{{\color{red} [\sout{#1} {\color{magenta} #2}]}}
\else
\newcommand{\todo}[1]{}
\newcommand{\sstucki}[1]{}
\newcommand{\manojo}[1]{}
\newcommand{\comm}[1]{}
\newcommand{\orElse}[2]{#2}
\renewcommand{\sout}[1]{}
\fi
% paper specific commands
\newcommand{\tool}{Yin-Yang\xspace}



\begin{document}

\title{Yin-Yang: Concealing the Deep Embedding of DSLs}

\author{Vojin Jovanovic and Amir Shaikhha}

\institute{Ecole Polythechnique Federale de Lausanne, EPFL\\
\email{\{first\}.\{last\}@epfl.ch}}

\maketitle

\begin{abstract}
Deeply embedded domain-specific languages (EDSLs) inherently compromise programmer experience for improved program performance. Shallow EDSLs complement them by trading program performance for good programmer experience. We present Yin-Yang, a framework for DSL embedding that uses Scala reflection to reliably translate shallow EDSL programs to the corresponding deep EDSL programs. The translation allows program prototyping and debugging in the user friendly shallow embedding, while the corresponding deep embedding is used in production\textemdash where performance is important. The reliability of the translation completely conceals the deep embedding from the DSL user. For the DSL author, Yin-Yang generates the deep DSL embeddings from their shallow counterparts by reusing the core translation. This obviates the need for code duplication and assures that the implementations of the two embeddings are always synchronised.
\end{abstract}
% \category{D.3.3}{Programming Languages}{Language Constructs and Features}

\keywords
Embedded Domain-Specific Languages, Macros, Deep Embedding, Shallow Embedding, Compile-Time Meta-Programming

\section{Introduction}

% External DSLs
External Domain-specific languages (DSLs) are languages with a custom compiler specialized to a particular application domain. Knowledge about the domain and language specialization give the compiler possibilities for optimization that do not exist in general purpose languages. The restricted language makes it easy for \emph{DSL users} to learn the language while the optimizations can yield execution times close to hand-optimized programs \cite{rompf_optimizing_2013}.

% Embedded DSLs
Development of external DSLs includes building a parser and type checker as well as a large tool-chain (i.e., debuggers, IDEs, and documentation tools). An appealing alternative are \emph{embedded DSLs}~(EDSLs)~\cite{Hudak96csur} that reuse the parser, type checker and the tool-chain of the general-purpose \emph{host language} to minimize required development effort. We can classify DSL embeddings into two categories:

\begin{itemize}

\item \emph{Shallow embeddings} where values in the embedded language are \emph{directly} represented by the values in the host language. A special sub-category of shallow embeddings are \emph{direct embeddings} where language constructs and term types are exactly the same as in the host language.

\item \emph{Deep embeddings} where values in the embedded language are symbolically (with data structures) represented in the host language.

\end{itemize}

Direct embeddings are typically friendly for the \emph{DSL user} as they \emph{i)} \emph{linguistically match} the host language and \emph{ii)} can be easily debugged since values of the embedded language directly correspond to the values of the host language. However, since programs can not be introspected, the number of possible domain-specific optimizations is limited.

% Deep embedding exhibits good performance but interface suffers
Deep embeddings reify the DSL programs into an \emph{intermediate representation} IR. The reification hinders usability as it often relies on complex type system constructs that create a linguistic mismatch with the host language. Furthermore, the IR construction prevents term introspection during debugging and makes the problem even harder. However, the domain knowledge about the IR opens opportunities for optimizations.

% DSL author goes through horror of making the interface usable


% Yin-Yang translates deep embedding into the shallow one

% Generation

\section{Demonstration: A DSL for In-Memory Queries}

  % We generate deep embedding for the shallow embedding
  Our demonstration shows how \tool is used for: \emph{i)} the DSL developer and \emph{ii)} the DSL user. For the purpose of the demonstration we use an existing DSL for writing in-memory queries.

  % We will write operators for the query language in the direct embeddings


  % From the direct embedding we will generate the deep embedding

  % We will write queries that use our new operators

  % Demonstrate the type errors, debugging, and prototyping.

  % Introduce optimizations


\bibliographystyle{plain}

\bibliography{vjovanov-lib,manual}

\end{document}



