>> (Reviewer 1) Programs written in Yin-Yang are fairly difficult to read.
>> (Reviewer 1) One wonders whether this can all be done already using Racket's powerful macro system.
>> (Reviewer 1) The fragments of formal semantics presented look buggy, but without the full semantics it is impossible to tell.
>> (Reviewer 1) The approach seems quite original, certainly in the context of Scala, though
>> one does wonder how much of this could already be done with Racket's macros. That
>> certainly would be interesting to know, though I admit the settings are quite different,
>> and that managing and exploiting types is one of the issues Yin-Yang has dealt
>> with, which would be irrelevant in the Racket setting.
>> Correctness can not be established using a case study. How does this claimed correctness relate to the formalism?

>> Reviewer 2: Fundamentally, this paper hides whatever "secret sauce" it is that
>> makes the idea work in a mass of Scala details, making the paper in
>> its current form unsuitable for publication.

>> Reviewer 2: As far as I understand it, the basic idea for transforming a shallow
>> embedding DSL into a deep one is to "virtualize" a program in the
>> shallow DSL by turning a set of host (Scala) language constructs into
>> constructors, e.g., "if" and "while". But then, what? That, at least
>> by itself doesn't seem to really provide all of the promised
>> benefits.  

>> Reviewer 2: The problem described in "Run-time domain-specific error reporting"
>> seems strange. If these are macros, why cannot the macro just do what
>> the text suggests it should do, namely check to see if the arguments
>> are constant? I think you're saying that you can do this, but you
>> would prefer to do it at compile-time for the host language and not
>> compile time for the DSL. But why would you prefer that? Compile-time
>> for the DSL seems like the right time to check this.

>> Meanwhile, the evaluation mostly focuses on correctness of the
>> translation. While it is good to know about correctness, the other
>> aspects of a deep DSL are not carefully discussed. There is the
>> tantalizing sentence "the captured variables analysis and guarded
>> re-compilation improved the performance of the query engine by 1-4x
>> (depending on the query)." but it is not clear exactly what improved
>> and why.

>> Reviewer 3: * From a scientific point of view, I would like to see a presentation
>>  that clearer separates the conceptual contributions from the 
>>  realization in a particular language/tooling/library setting. 
>>  In particular, it would be interesting to know what are the prerequisites
>>  of the host language to make the approach work. A list of 
>>  things are listed on the way of the description, but it remains
>>  a bit implicit what is actually needed (e.g., from the type system) and
>>  what is nice to have.
>> * The assumptions made should be stated explicitly, more prominently, and
>>  as soon as possible. E.g., no ealier than on page 19 you say "So far, we 
>>  assumed that there is no side-effect in the EDSL...." When reading the 
>>  text, I have several times tried to figure out what is assumed to make 
>>  the given statement true.
>> (* Shorten the text (several things are repeated) and enlarge the code 
>>   fragments to make them more readable)


We thank you very much for the time and effort invested in providing valuable comments. They pinpoint the weak spots in presentation and help us improve the future versions of this paper. You can find the answers to your questions below.
 
Reviewer_1:

Programs written in Yin-Yang are as readable as any Scala Library/Direct EDSL. The only difference is the additional macro call that puts a DSL body in a Yin-Yang scope (e.g., query {<dsl-body>}). Code generated by the translation is verbose and unreadable, but this is never visible to the programmer. 

The full formalization was omitted due to its verbosity. One can refer to the work of Carette et al. [9] where the “Complete Abstraction” translation (Section 4.1) is formalized and proven correct. In the evaluation section we discuss the correctness of the implementation since Scala is more complex than the lambda-calculus. 
  
Yin-Yang addresses problems related to statically typed languages so the whole system would make sense only in Typed Racket. There, it could be implemented as a macro-based library.


Reviewer_2:

The core translation consists of virtualization followed by DSL intrinsification (Section 4). Intrinsification consists of i) operation translation and ii) type translation. 

*Operation translation* simply injects the shallow DSL expressions in the deep embedding. This is langauge/implementation specific that we might change in the future so we elided the details.

*Type translation* ensures typechecking of the program in the deep embedding and introduces the complex types of the deep embedding that the user would usually face. There are several alternative type translations that are described in section 4.1. The most important ones are "Complete Abstraction" (proven correct by previous work) and "Automatic Inlining" that is used by LMS.

Could error-reporting be performed by a macro? It could, but the implementer would have to reason across all Scala trees as opposed to the restricted trees of the deep DSL. This is extremely difficult in a complicated language, like Scala, that has modules, named arguments, currying, overloading, overriding etc. The main contribution here is that error reporting is implemented on the simple DSL trees but still executed at host-language compile-time. 

In the evaluation we talk about performance improvements gained from guarded re-compilation. This is a part of Yin-Yang we talk about in (Section 6.4). We elide the details as this topic is out of the scope of this paper. The essence is that we reify deep DSLs only when captured variables change their value. This significantly improves performance of DSLs in latency critical scenarios.


Reviewer_3:
  
The assumptions are that we are operating in a statically-typed language and that EDSLs are based on the rank-1 polymorphic lambda-calculus. Yin-Yang can be implemented either as a compiler plugin, or as a library if the macro-system supports transformations of both type and expression trees (e.g., Template Haskell would not work). We will make our assumptions clear in the future versions of the paper.

For the DSL compilation at host-language compile-time the host language must support interpretation of expression trees at compile-time. In Scala this is possible by reflective compilation (`eval`).


