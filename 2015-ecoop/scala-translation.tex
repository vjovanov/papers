\section{Translating Scala to the Core Calculus}
\label{sct:scala-translation}

% Description of the chapter

The core calculus \sct{sct:formalization} captures the essence of user-controlled
 predictable partial-evaluation. In practice, though, it requires an inconveniently large number
 of \code{inline} calls. Moreover, the calculus does not provide a way to define
 data structures that would correspond to \emph{classes} in modern multi-paradigm languages.
 In this section we formalize convenient implicit conversions for the calculus \sct{sct:conversions}, a scheme for
 translating classes into the calculus how to promote constructs classes and \emph{methods} into their
 partially-evaluated versions \sct{sct:promotion}.

% Restricted Language

The core rules of the calculus do not support effect-full computations and each
 \code{inline} term is trivially converted to a dynamic term after erasure.
 In case of languages that do support mutable state and side-effects this needs to
 be treated specially. For simplicity, we omit side-effects from our discussion and
 assume that all partially evaluated code is side-effect free and that each
 \code{inline} term can be converted to dynamic code.

\subsection{Implicit Conversions}
\label{sct:conversions}

% Translated
One of the core assumptions of the calculus is that all \code{static} terms can
 always be promoted to \code{inline}. In case of function interfaces, e.g. the
 \code{dot} function in \sct{sct:introduction}, that user should not manually
 promote all arguments to \code{inline}. As a convenience for a library user
 we provide a type-driven conversion by default (C-StaticInline in \figref{fig:conversions}).

\begin{figure}

  \infrule[\textsc{C-StaticInline}]
    {\Gamma \ts t_1: \i{(\inline{T_1} \ra \k{T_2})} \ \ \ \ \Gamma \ts t_2: \static{T_1}}
    {\Gamma \ts \pe{t_1 (t_2) : \k{T_2}}{t_1 (\inline{t_2}) : \k{T_2}}}

\caption{Type-driven conversions from \code{static} terms to \code{inline} terms.}
\label{fig:conversions}
\end{figure}

\subsection{Making Object Oriented Constructs Partially Evaluated}
\label{sct:promotion}

\begin{figure}
  $ [[ let\ x: T_x = t_x\ in\ t ]] = \\ $
  $ ((x: T_x) \ra t)(t_x) \\ \\$
  $ [[ let\ type\ T_1 = T_2\ in\ t ]] = \\ $
  $ ([T_1 <: T_2] \ra t)[T_2] \\ \\ $
  $ [[ let\ class\ C[A](x: T_x) \{ def\ f[B](y: T_y) = t_f \}\ in\ t ]] = \\ $
  $ \ let\ type\  C = [A] \ra \{ x: T_x, f: [B] \ra T_y \ra T_f \}\ in \\ $
  $ \ let\ C: [A] \ra (x: T_x) \ra C[A] = [A] \ra (x: T_x) \ra \{ x = x, f = [B] \ra (y: T_y) \ra t_f \}\ in\ t$
\end{figure}

\begin{figure}
\begin{multicols}{2}[]

  \infrule[\textsc{CT-TVar}]
    {\Pi \ts T \in \Pi}
    {\Pi \ts \pe{iT}{iT}}

  \infrule[\textsc{CT-T-Var}]
    {\Pi \ts T \not\in \Pi}
    {\Pi \ts \pe{iT}{\inline{T}}}

\end{multicols}
\vspace{4pt}

  \infrule[\textsc{CT-Rec}]
    {\seq{\Pi \ts \pe{t}{t'}}}
    {\Pi \ts \pe{\i\{ \seq{x = t} \}}{\inline{\{ \seq{x = t'} \}}}}

  \infrule[\textsc{CT-T-Rec}]
    {\seq{\Pi \ts \pe{\i{T}}{\j{T}}}}
    {\Pi \ts \pe{\{\seq{x : \i{T}}\}}{\inline{\{ \seq{x : \j{T}}}\}}}

  \infrule[\textsc{CT-T-Arrow}]
    {\Pi \ts \pe{\i{T}}{\j{T}} \ \ \ \  \Pi \ts \pe{\k{S}}{\l{S}} }
    {\Pi \ts \pe{\i{T} \Rightarrow \k{S}}{\j{T} \Rightarrow \l{S}}}

  \infrule[\textsc{CT-T-Univ}]
    {\Pi \ts \pe{\j{T}}{\k{T}}}
    {\Pi \ts \pe{[X <: \i{S}] \ra \j{T}}{[X <: \i{S}] \ra \k{T}}}

  \infrule[\textsc{CT-Func}]
    {\Pi \ts \pe{t}{t'} \ \ \ \ \Pi \ts \pe{iT}{jT}}
    {\Pi \ts \pe{\i(x: iT) \ra t}{\inline{(x: jT) \ra t'}}}

  \infrule[\textsc{CT-TAbs}]
    {\Pi,\ X \ts \pe{t}{t'}}
    {\Pi \ts \pe{\i([X <: \j{T_1}] \ra t)}{\inline{([X <: \j{T_1}] \ra t'})}}

  \infrule[\textsc{CT-TApp}]
    {\Pi \ts \pe{t}{t'} \ \ \ \ \Pi \ts \pe{\i{T}}{\j{T}}}
    {\Pi \ts \pe{t[\i{T}]}{t'[\j{T}]}}

\caption{Translation of a regular class to a compile-time version.}
\label{fig:partial-evaluation}
\end{figure}
