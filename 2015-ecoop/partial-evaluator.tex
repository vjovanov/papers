\section{The Partial Evaluator for Scala}
\label{sct:interface}

\todo{cite github}
We have implemented a prototype partial evaluator \sct{sct:partial-evaluation} and
 the desugaring \sct{sct:scala-translation} for the Scala language. The partial evaluator
 is a compiler plugin that executes in a phase after the Scala type checker. The plugin starts
 with pre-typed Scala programs and uses a type annotations \todo{cite} to track and verify
 information about the biding-time of terms.

To the user, the partial evaluator exposes a minimal interface (\figref{fig:interface}) with
\code{inline} and \code{ct} annotations and the \code{ct} function.

\begin{figure}
\begin{listing}
package object scalainline {
  final class ct extends StaticAnnotation

  @compileTimeOnly def ct[T](body: => T): T = ???

  final class inline extends StaticAnnotation
}
\end{listing}
\label{fig:interface}
\caption{Interface of the Scala partial evaluator.}
\end{figure}

Annotation \code{@ct} is used at the type level and denotes that one expects a
 compile-time view of a type. The annotation is integrated in the Scala's type system
 and, therefore, can be arbitrarily nested in different variants of types. Table
 \ref{tbl:ct-type} shows how the \code{@ct} annotation can be placed on types
 and how it, due to the translation to the compile-time views (\figref{ct-translation}),
 changes method signature.

\begin{table}[h]
\caption{Types and corresponding method signatures after the translation to the compile-time view.}
\label{tbl:ct-type}
\centering
\begin{tabularx}{\linewidth}{ X X X }
\toprule

  Annotated Type             \quad \quad \quad & Type's Method Signatures                          &  \\
  \code{Int@ct}              \quad \quad \quad & \code{+(rhs: Int@ct): Int@ct}                     &  \\
  \code{Vector[Int]@ct}      \quad \quad \quad & \code{map[U](f: (Int => U)@ct): Vector[U]@ct}     &  \\
                             \quad \quad \quad & \code{length: Int@ct}                             &  \\
  \code{Vector[Int@ct]@ct}   \quad \quad \quad & \code{map[U](f: (Int@ct => U)@ct): Vector[U]@ct}  &  \\
  \code{Map[Int@ct, Int]@ct} \quad \quad \quad & \code{get(key: Int@ct): Option[Int]@ct}           &  \\

\bottomrule
\end{tabularx}
\end{table}

In \tabref{tbl:ct-type}, \code{Int@ct} is a non-polymorphic type and therefore
 according to the translation to the compile-time view (\ref{fig:ct-translation})
 all arguments of all methods will be compile-time. On the other hand, \code{Vector[Int]@ct} will
 have all arguments of all methods transformed except the generic ones. Function \code{f}
 passed to \code{map} accepts a dynamic value as input.

\begin{lstparagraph}
& All operations on Int executed at compile-time.
& \code{map} executed at compile-time, over dynamic values.
& Length is executed at compile-time; result is compile-time.
& \code{map} executed at compile-time over compile-time values. The result can still be both dynamic and @ct.
& Map
\end{lstparagraph}

Method \code{ct} is used at the term level for promoting Scala objects and functions into
 their compile-time views.

\begin{table}[h]
\caption{Types and corresponding method signatures after the translation to the compile-time view.}
\label{tbl:ct-type}
\centering
\begin{tabularx}{\linewidth}{ X X }
\toprule

  Promoted Term        \quad \quad \quad & Term's Promoted Type             \\
  \code{ct(Vector)(1, 2, 3)            } & \code{: Vector[Int]@ct        }  \\
  \code{ct(Vector)(ct(1), ct(2), ct(3))} & \code{: Vector[Int@ct]@ct     }  \\
  \code{ct((x: Int) => x)              } & \code{: (Int => Int)@ct       }  \\
  \code{ct((x: Int@ct) => x)           } & \code{: (Int@ct => Int@ct)@ct }  \\
  \code{new (Cons@ct)(1, Nil)          } & \code{: Cons[Int]@ct          }  \\
  \code{new (Cons@ct)(ct(1), ct(Nil))  } & \code{: Cons[Int@ct]@ct       }  \\

\bottomrule
\end{tabularx}
\end{table}

 \begin{lstparagraph}

\end{lstparagraph}

Annotation \code{@inline} can be used only on methods and functions. This function
uses partial evaluation to achieve inlining\todo{cite}. This is not the first time that
inlining is achieved through partial evaluation\todo{cite}, however, partial evaluation is
trivially added to the system. It directly corresponds to adding \code{inline} from
\calculus in front of the function or method definition.

\subsection{Interaction with the Scala Language}
