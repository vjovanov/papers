\documentclass[paper.tex]{subfiles}

\begin{document}

\section{Background on Scala}
\label{sec:background}

In this section we provide information necessary for understanding \tool's
implementation in Scala. We briefly explain Scala Macros
\cite{burmako_scala_2013} and Lightweight Modular Staging
\cite{rompf_lightweight_2012,rompf_optimizing_2013}.
Throughout the paper we assume familiarity with the basics of the
Scala Programming Language \cite{odersky_scala_2004}.

\subsection{Scala Macros}
\label{sec:scala-macros}

% What are scala macros and how are they defined.
Scala Macros \cite{burmako_scala_2013} are a compile-time meta-programming
feature of Scala. Macros are written as programs that operate on Scala abstract syntax trees (ASTs). They can construct new ASTs, or transform and analyze the existing Scala ASTs. Macro programs can use common functionalities of the Scala compiler like error-reporting, type checking, transformations, traversals, and implicit search. Currently, macro definitions are abstracted by the regular method bodies. The difference is that arguments to the macro function definitions are type-checked trees of the arguments.

%Eval
Additionally, macros have access to the \code{eval[T](e: Expr[T]): T} function that will reflectively compile the expression \code{e}, load and run the compiled code, and return the result at compile time. We use this facility for instantiating EDSLs to achieve compile-time domain-specific error reporting cf. \sct{sec:interface} and code generation cf. \sct{subsec:ctcg}.

%Users
For users, macro invocations are presented as regular method calls. The
difference is that the body of the method operates on ASTs and will be
executed at compile-time while its result is inlined at the invocation site.
All the arguments to the method call are fully type-checked before macro
expansion. An example of a macro that evaluates a $pow$ function with constant
arguments at compile-time is presented in \figref{lst:macro}: the \code{evalPow} function defers its implementation to the \code{_evalPowImpl} macro. At compile-time, we check whether, under the compilation context \code{c}, the expression matches a call to the \scode{pow} function, with literals as arguments. Note that we use quasiquotes (expressions inside \code{q""} strings) to abstract over compiler ASTs~\cite{shabalin_quasiquotes_2013}.

\lstset{mathescape=false}
\begin{figure}
\begin{listingtiny}
def evalPow(expr: Double): Double = macro _evalPowImpl
def _evalPowImpl(c: Context)(expr: c.Expr[Double]): c.Expr[Double] = {
  import c.universe._
  expr.tree match {
    case q"math.pow(${b: Literal}, ${e: Literal})" =>
      c.Expr(q"${c.eval[Double](expr)}")
    case _ => expr
  }
}
\end{listingtiny}
\caption{\label{lst:macro} Macro that evaluates a \code{pow} function at compile-time if arguments are literals.}
\end{figure}
\lstset{mathescape=true}



\comm{
In the event of a match, we evaluate the expression (using the \code{eval} function). Otherwise, we return the same expression. For clarity purposes:

\begin{itemize}
\item \code{evalPow(math.pow(x,2))} will remain the same.
\item \code{evalPow(math.pow(3,2))} will be rewritten as \code{9}.
\end{itemize}

\begin{comment}
$ makes highlighting work in sublime! No it does not :)
\end{comment}
}

\subsection{Deep Embedding of DSL with LMS}
\label{subsec:deep-embedding}

% Cake Pattern
\comm{Odersky and Zenger \cite{odersky_scalable_2005} describe reusable component systems for Scala, with interfaces for required and provided
services, without hard references. Scala components are based on abstract type members, selftypes, and mix-in composition. Abstract
type members allow to abstract over types of components and provide easy parametrization through inheritance. Selftype annotations declare
the type of \code{this} which states the required interfaces and allows for the transparent reuse of dependent components. Mix-in composition
is used to compose different components without hard references, while providing guarantees about correct component dependencies. Without
loosing generality we focus on EDSLs that are based on Scala components.}

% LMS
Lightweight Modular Staging (LMS) is a staging \cite{taha_multi-stage_1997} framework and an embedded compiler for developing deep
\edsls. The LMS \edsl programs are written inside the scope of a \emph{trait} that forms a \emph{mix-in} composition of all \edsl components \cite{odersky_scalable_2005}. Each trait in the composition introduces \edsl declarations in the scope of the program. In \figref{lst:lms} we see the trait \code{VectorDSL} that defines a simplified \edsl for creating numerical vectors. In the mix-in composition, \code{Base} introduces core LMS constructs (e.g., \code{Rep[_]}), and \code{NumericOps} introduces the type class for numeric operations. The example usage of the \edsl is displayed in the bottom of the figure.


\begin{figure}
\begin{listingtiny}
// The EDSL declaration
trait VectorDSL extends NumericOps with Base {
  object Vector {
    def fill[T:Numeric](value: Rep[T], size: Rep[Int]): Rep[Vector[T]] =
      vector_fill(value, size)
  }

  implicit class VectorOps[T:Numeric](v: Rep[Vector[T]]) {
    def +(that: Rep[Vector[T]]): Rep[Vector[T]] = vector_+(v, that)
  }
  // Operations vector_fill and vector_+ are elided
}

new VectorDSL { // EDSL program
  Vector.fill(lift(1),lift(3)) + Vector.fill(lift(2), lift(3))
} // returns a regular Scala Vector(3,3,3)
\end{listingtiny}
\caption{\label{lst:lms} Minimal EDSL for vector manipulation.}
\end{figure}

All types in the \code{VectorDSL} interface are a parametric type \code{Rep[_]}. The type \code{Rep[_]} abstracts over IR nodes of the deep \edsl. It denotes that a term with type \code{Rep[T]} will evaluate to a term of type \code{T} after \edsl execution.

Operations on \code{Rep[T]} terms are added by implicit conversions \cite{oliveira_type_2010}. For example, the implicit class \code{VectorOps} introduces the \code{+} operation on every term of type \code{Rep[Vector[T]]}. The type class \code{Numeric} ensures that vectors contain only numerical velues. This type class is introduced into the scope by the \code{NumericOps} trait.

% LMS Compiler
The LMS framework is modular and each module is defined as a separate trait. The framework includes an embedded compiler that explicitly tracks effects and applies loop fusion, decomposition of structures, and code motion. Common compiler optimizations, like CSE and DCE, are performed on both high-level DSL abstractions and low level code. Depending on the code generation trait used, the output of the compilation can be Scala, C/C++, CUDA, or JavaScript code.

% Statement about successful use
LMS has been successfully used by Ackermann et al. \cite{ackermann_jet:_2012} for distributed processing, and by Ureche et al. \cite{ureche_stagedsac:_2012} for multi-dimensional array processing. Brown et al. present Delite \cite{brown_heterogeneous_2011,composition-ecoop2013}, a heterogeneous parallel computing
framework based on LMS. \edsls developed with Delite cover domains of machine learning, graph processing, data mining, mathematics etc. Due to its wide use and high-performance we choose it as a back-end for \tool.

\end{document}
