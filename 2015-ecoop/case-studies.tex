\section{Case Studies}
\label{sct:case-studies}

In this section we present selected use-cases for compile-time views that demonstrate
 the core functionality. We start with a canonical example of the power function
 (\sct{sct:recursion}), then we demonstrate how variable argument functions can be
 desugared into the core functionality (\sct{sct:varargs}). Finally, we demonstrate how
 the abstraction overhead of the \code{dot} function and all associated type-classes
 can be removed (\sct{sct:dot-product}).

\subsection{Recursion}
\label{sct:recursion}

The canonical example in partial evaluation is the computation of the integer power
 function:

\begin{listing}
def pow(base: Double, exp: Int): Double =
  if (exp == 0) 1 else base * pow(base, exp)
\end{listing}

When the exponent (\code{exp}) is statically known this function can be partially
evaluated into \code{exp} multiplications of the \code{base} argument, significantly
improving performance~\cite{}.

With compile-time views making \code{pow} partially evaluated requires adding two annotations:

\begin{listing}
@inline def pow(base: Double, exp: Int @ct): Double =
  if (exp == 0) 1 else base * pow(base, exp)
\end{listing}

\code{@inline} denotes that the \code{pow} function it self must be inline and
 \code{@ct} requires that the \code{exp} argument is a compile-time view of \code{Int}.

\subsection{Variable Argument Functions}
\label{sct:varargs}

\begin{itemize}
  \item \code{@i?} in argument position is a macro that expands the function to an underlying function \code{@i? def min_underlying[T: Numeric](values:Seq[T]@i?): T} and a macro that will call it according to the input parameters.
  \item Comparison to other approaches.
\end{itemize}

\begin{figure}
\begin{listing}
def min[T: Numeric](@ct values:T*): T =
  values.tail.foldLeft(values.head)((min, el) => if (el < min) el else min)
\end{listing}
\caption{\label{lst:vector_deep_ir} Function for computing the non-negative power of a real number.}
\end{figure}



\subsection{Inline Classes: Butterfly Networks}
\begin{itemize}
  \item Reference LMS. Discuss @i! annotation on classes. Works for both dynamic and static inputs.
  \item Comparison to LMS. Mention a pervasive number of annotations. Discuss duality of Exp[T] and @i!.
\end{itemize}




\subsection{Dot Product}
\label{sct:dot-product}
\begin{itemize}
  \item Explain the removal of type classes together with inline. Explain how type classes
  are @i? and how they will completely evaluate if they are passed a static value.
  \item Comparison to other approaches.
\end{itemize}


\begin{figure}
\begin{listing}
object Numeric {
  @i! implicit def dnum: Numeric[Double] @i! = DoubleNumeric
  @i! def zero[T](implicit num: Numeric[T]): T = num.zero
  object Implicits {
    @i! implicit def infixNumericOps[T](x: T)(implicit num: Numeric[T]): Numeric[T]#Ops = new num.Ops(x)
  }
}
trait Numeric[T] {
  def plus(x: T, y: T): T
  def times(x: T, y: T): T
  def zero: T

  @i! class Ops(lhs: T) {
    @i! def +(rhs: T) = plus(lhs, rhs)
    @i! def *(rhs: T) = times(lhs, rhs)
  }
}

object DoubleNumeric extends Numeric[Double] {
  @i! def plus(x: Double @i?, y: Double @i?): Double = x + y
  @i! def times(x: Double @i?, y: Double @i?): Double = x * y
  @i! def zero: Double = 0.0
}
\end{listing}
\caption{\label{lst:vector_deep_ir} Function for computing the non-negative power of a real number.}
\end{figure}
