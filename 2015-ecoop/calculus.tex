\clearpage
\section{Formalization $F_{i <:}$}

\begin{figure}
\begin{multicols}{2}
\syntaxfig{
  t ::=                             & \lindent{\mbox{Terms:}}            \\
  \gap x, y                         & \mbox{identifier}                  \\
  \gap (x: \i{T}) \ra t             & \mbox{function}                    \\
  \gap t(t)                         & \mbox{application}                 \\
  \gap \{ \seq{x = t} \}            & \mbox{record}                      \\
  \gap t.x                          & \mbox{selection}                   \\
  \gap \ct t                        & \mbox{inlining request}            \\
  \gap [X <: \i{T}] \ra t           & \mbox{type abstraction}            \\
  \gap t [\i{T}]                    & \mbox{type application}            \\
  \Gamma ::=                        & \lindent{\mbox{Contexts:}}         \\
  \gap \emptyset                    & \mbox{empty context}               \\
  \gap \Gamma,\ x: iT               & \mbox{term binding}                \\
  \gap \Gamma,\ X <: iT             & \mbox{type binding}                \\
}
\syntaxfig{
  S,\ T,\ U ::=                     & \lindent{\mbox{Types:}}            \\
  \gap \i{S} \ra \j{T}              & \mbox{function type}               \\
  \gap \{ \seq{x: \i{S}} \}         & \mbox{record type}                 \\
  \gap [X <: \i{S}] \ra \j{T}       & \mbox{universal type}              \\
  \gap Any                          & \mbox{top type}                    \\
  \i{T},\ \j{T},\ \k{T},\ \l{T} ::= & \lindent{\mbox{Inlineable Types:}} \\ 
  \gap X                            & \mbox{type identifier}             \\
  \gap T,\ \dynamic{T}              & \mbox{dynamic type}                \\
  \gap \static{T}                   & \mbox{static type}                 \\
  \gap \inline{T}                   & \mbox{must inline type}            \\
}
\end{multicols}
\caption{Syntax of $F_{i<:}$}
\end{figure}

We formalize the essence of our inlining system in a minimalistic calculus based 
on $F_{<:}$ with records. To accomodate inlining we introduce binding-time annotations 
into the type system as first-class type production rules that represent three kinds 
of bindings:

\begin{enumerate}
  \item \textbf{Dynamic binding}. These are the types which express computation at runtime.
        All types written in the end user code are considered to be dynamic by default if
        no other binding-time annotation is given.

  \item \textbf{Static binding}. Values of static terms can be computed at compile-time
        (\eg constant expressions) but at are still evaluated at runtime by default.
        All language literals are static by default (\textsc{T-Rec}, \textsc{T-Func}).

  \item \textbf{Inline binding}. And finally the types that correspond to terms that
        are hinted to be computed at compile-time whenever possible. 
\end{enumerate}

\iffalse
Due to the fine-grain nature of our inlining system every type in the system has to 
have corresponding inlinity attributed. This makes it possible to compose compound
types that mix compile-time evaluated inline components and runtime evaluated dynamic
ones. For example given a following variable in lexical scope:  
\begin{equation}\nonumber
    complex: \static{\{ isPolar: \inline{Boolean}, a: Double, b: Double \}} 
\end{equation}

We might both perform purely compile-time computation based on $config$ field 
using $(\inline{app}).config$ and runtime call to $main$ via $app.main()$. This example 
illustrates that we need all subtrees of our term to be inline for inli\fng to happen 
(\textsc{T-Sel}, \textsc{T-App}). We encode the notion of least inlinity through inlinity
intersection $\Gamma \ts i \wedge \j{T} = \k{T}$ relation.

Another notable feature of our model is tight integration between inlinity information and
generics with respect to subtyping (\textsc{T-TAbs}, \textsc{T-TApp}) that allows us to
abstract over inlinity without any extra features apart from regular type polymorphism.
For example lets have a look at simple polymorphic identity function:
\begin{equation}\nonumber
    [T <: Any] \ra (x: T) \ra x: \static{([T <: Any] \ra \static{(T \ra T)})}
\end{equation}

Depending on the input's inlinity this function might be itself inlineable or not. For example
given a static input literal integer it would produce static integer as a result meaning that 
computation itself can be inlined if user asks the system to perform it. This allows
us to easily encode operations which are polymorphic in inlinity of arguments.

Unification of inlinity and regular type polymorphism is possible due to the fact that type
inlinity is integrated into subtyping relation through (\textsc{S-Inline}) rule which merges
subtyping of regular types and inlinity state on a type.

\fi

\subsection{Composition}

In our system every type contains a binding time information. Moreover, parts of composed
types like records or function types can have varying binding times leading to interesting 
combinations which let users partially evaluate only specific components of data structures.

To start compile-time partial evaluation one needs to use $\inline{t}$ term that creates a 
compile-time view of the term $t$. This operation doesn't require all of the $t$ be
known statically, only the outer most layer. For example lets have a look at simple record
that describes a complex number with two possible representations encoded through $isPolar$ flag:
\begin{equation}\nonumber
    complex: \static{\{ isPolar: \inline{Boolean},\ a: Double,\ b: Double \}} \in \Gamma
\end{equation}

This type is composed out a number of components all of which have varying binding times. 
Representation encoding is known in advance and hinted to be optimized away whenever possible.
Coordinates $a$ and $b$ do not have any binding-time annotation meaning that they are expected
to be dynamic. Finally the outer record type has statically known structure. 

Given this binding to $complex$ in our environment $\Gamma$ we can use $inline$ to obtain
a compile-time view to access $isPolar$ field:
\begin{equation}\nonumber
  (\inline{complex}).isPolar: \inline{Boolean}
\end{equation}

Any statically known type can be promoted to become $inline$. For operation to happen at 
compile-time all of its subterms must be inline. If we were to use regular field selection
on $complex$ we would have got a different result:
\begin{equation}\nonumber
  complex.isPolar: \static{Boolean}
\end{equation}

This is encoded in our typing rules through binding-time intersection.

\begin{figure}
  \infrule
  {\Gamma \ts i <: j}
  {\Gamma \ts i \wedge \j{T} = \j{T}}
  \caption{Binding-time intersection.}
\end{figure}

The only role of this relation is to pick least binding-time annotation 
of the subterms. In our previous example the least binding time is $static$ 
because $complex$ is $static$.

\subsection{Subtyping}

\begin{figure}
\begin{multicols}{2}
  \infax[\textsc{S-Top}]
  {\Gamma \ts \i{S} <: Any}

  \infax[\textsc{S-Refl}]
  {\Gamma \ts \i{S} <: \i{S}}

  \infrule[\textsc{S-Trans}]
  {\Gamma \ts \i{S} <: \j{U} \ \ \ \ \Gamma \ts \j{U} <: \k{T}}
  {\Gamma \ts \i{S} <: \j{U}}

  \infrule[\textsc{S-TVar}]
  {X <: \i{T} \in \Gamma}
  {\Gamma \ts X <: \i{T}}

  \infax[\textsc{S-Width}]
  {\{ x_p: i_p T_p\ ^{p \in 1..n+m} \} <: \{ x_p: i_p T_p\ ^{p \in 1..n} \}}

  \infrule[\textsc{S-Arrow}]
  {\Gamma \ts \k{T_1} <: \i{S_1} \ \ \ \ \Gamma \ts \j{S_2} <: \l{T_2}}
  {\Gamma \ts \i{S_1} \ra \j{S_2} <: \k{T_1} \ra \l{T_2}}

  \infrule[\textsc{S-Depth}]
  {\forall p \in 1..n.\ i_p S_p <: j_p T_p}
  {\{ x_p: i_p S_p\ ^{p \in 1..n}\} <: \{ x_p: j_p T_p\ ^{p \in 1..n} \}}

  \infrule[\textsc{S-Inline}]
  {i <: j \ \ \ \ \Gamma \ts S <: T}
  {\Gamma \ts \i{S} <: \j{T}}
\end{multicols}
  \vspace{6pt}
  \infrule[\textsc{S-All}]
  {\Gamma,\ X <: \i{U_1} \ts \j{S_2} <: \k{T_2}}
  {\Gamma \ts [X <: \i{U_1}] \ra \j{S_2} <: [X <: \i{U_1}] \ra \k{T_2}}
  \vspace{6pt}
  \infrule[\textsc{S-Perm}]
  {\{ x_p : i_p S_p\ ^{p \in 1..n}\} $ is permutation of $ \{ y_p: j_p T_p\ ^{p \in 1..n} \}}
  {\{ x_p : i_p S_p\ ^{p \in 1..n}\} <: \{ y_p: j_p T_p\ ^{p \in 1..n} \} }
\caption{Subtyping.}
\end{figure}

\subsection{Well-formed types}

\begin{figure}
\begin{multicols}{2}
  \infax[\textsc{I-Dynamic}]{\Gamma \ts i <: dynamic}

  \infax[\textsc{I-Static1}]{\Gamma \ts static <: static}

  \infax[\textsc{I-Static2}]{\Gamma \ts inline <: static}

  \infax[\textsc{I-Inline}]{\Gamma \ts inline <: inline}

  \infrule[\textsc{I-Ident}]
  {X <: \j{T} \in \Gamma \ \ \ \ \Gamma \ts i <: j}
  {\Gamma \ts i <: X}
\end{multicols}
\caption{Binding-time subtyping.}
\end{figure}

\subsection{Generics}

\begin{figure}
\begin{multicols}{2}
  \infrule[\textsc{T-Ident}]
  {x: \i{T} \in \Gamma}
  {\Gamma \ts x: \i{T}}

  \infrule[\textsc{T-Func}]
  {\Gamma,\ x: \i{T_1} \ts t: \j{T_2}}
  {\Gamma \ts (x: \i{T_1}) \ra t : \static{\i{T_1} \ra \j{T_2}}}

  \infrule[\textsc{T-Rec}]
  {\Gamma \ts \seq{t: \i{T}}}
  {\Gamma \ts \{ \seq{x = t} \} : \static{\{\seq{x: \i{T}}\}}}

  \infrule[\textsc{T-App}]
  {\Gamma \ts t_1: \i{(\j{T_1} \ra \k{T_2})} \ \ \ \ \Gamma \ts t_2: \j{T_2}}
  {\Gamma \ts t_1 (t_2) : i \wedge j \wedge \k{T_2}}

  \infrule[\textsc{T-Sel}]
  {\Gamma \ts t: \i{\{ x = \j{T_1}, \seq{y = \k{T_2}} \}}}
  {\Gamma \ts t.x : i \wedge \j{T_1}}

  \infrule[\textsc{T-Inline}]
  {\Gamma \ts t: \static{T}}
  {\Gamma \ts \ct{t}: \inline{T}}

  \infrule[\textsc{T-Sub}]
  {\Gamma \ts t: \i{S} \ \ \ \ \Gamma \ts \i{S} <: \j{T}}
  {\Gamma \ts t: \j{T}}
\end{multicols}
  \vspace{4pt}
  \infrule[\textsc{T-TAbs}]
  {\Gamma,\ X <: \i{T_1} \ts t_2: \j{T_2}}
  {\Gamma \ts [X <: \i{T_1}] \ra t_2: \static{[X <: \i{T_1}] \ra \j{T_2}}}
  \vspace{4pt}
  \infrule[\textsc{T-TApp}]
  {\Gamma \ts t_1: \i{([X <: \j{T_{11}}] \ra \k{T_{12}})}  \ \ \ \ \Gamma \ts \l{T_2} <: \j{T_{11}}} 
  {\Gamma \ts t_1[\l{T_2}] : [X \mapsto \l{T_2}] i \wedge \k{T_{12}}}
\caption{Typing.}
\end{figure}

\clearpage
