\clearpage
\section{Formalization $F_{i <:}$}

\begin{figure}
\begin{multicols}{2}
\syntaxfig{
  t ::=                             & \lindent{\mbox{Terms:}}            \\
  \gap x, y                         & \mbox{identifier}                  \\
  \gap (x: \i{T}) \ra t             & \mbox{function}                    \\
  \gap t(t)                         & \mbox{application}                 \\
  \gap \{ \seq{x = t} \}            & \mbox{record}                      \\
  \gap t.x                          & \mbox{selection}                   \\
  \gap \inline{t}                   & \mbox{}                            \\
  \gap \dynamic{t}                  & \mbox{}                            \\
  \gap [X <: \i{T}] \ra t           & \mbox{type abstraction}            \\
  \gap t [\i{T}]                    & \mbox{type application}            \\
  \Gamma ::=                        & \lindent{\mbox{Contexts:}}         \\
  \gap \emptyset                    & \mbox{empty context}               \\
  \gap \Gamma,\ x: iT               & \mbox{term binding}                \\
  \gap \Gamma,\ X <: iT             & \mbox{type binding}                \\
}
\syntaxfig{
  S,\ T,\ U ::=                     & \lindent{\mbox{Types:}}            \\
  \gap \i{S} \ra \j{T}              & \mbox{function type}               \\
  \gap \{ \seq{x: \i{S}} \}         & \mbox{record type}                 \\
  \gap [X <: \i{S}] \ra \j{T}       & \mbox{universal type}              \\
  \gap Any                          & \mbox{top type}                    \\
  \i{T},\ \j{T},\ \k{T},\ \l{T} ::= & \lindent{\mbox{Inlineable Types:}} \\
  \gap X                            & \mbox{type identifier}             \\
  \gap T,\ \dynamic{T}              & \mbox{dynamic type}                \\
  \gap \static{T}                   & \mbox{static type}                 \\
  \gap \inline{T}                   & \mbox{must inline type}            \\
}
\end{multicols}
\caption{Syntax of $F_{i<:}$}
\end{figure}

We formalize the essence of our inlining system in a minimalistic calculus based
on $F_{<:}$ with records. To accommodate inlining we introduce binding-time annotations
into the type system as first-class type production rules that represent three kinds
of bindings:

\begin{enumerate}
  \item \textbf{Dynamic binding}. These are the types which express computation at runtime.
        All types written in the end user code are considered to be dynamic by default if
        no other binding-time annotation is given.

  \item \textbf{Static binding}. Values of static terms can be computed at compile-time
        (\eg constant expressions) but at are still evaluated at runtime by default.
        All language literals are static by default.

  \item \textbf{Inline binding}. And finally the types that correspond to terms that
        are hinted to be computed at compile-time whenever possible.
\end{enumerate}

\subsection{Composition}

An interesting consequence of encoding of binding times as first-class types is
ability to represent values which are partially static and partially dynamic.

For example lets have a look at simple record that describes a complex number with
two possible representations encoded through $isPolar$ flag:

\begin{equation}\nonumber
    complex: \static{\{ isPolar: \static{Boolean},\ a: Double,\ b: Double \}} \in \Gamma
\end{equation}

This type is constructed out of a number of components with varying binding times.
Representation encoding is known in advance and is static according to the signature.
Coordinates $a$ and $b$ do not have any binding-time annotation meaning that they are
dynamic.

Given this binding to $complex$ in our environment $\Gamma$ we can use $inline$ to obtain
a compile-time view to evaluate acess to $isPolar$ field at compile-time:
\begin{equation}\nonumber
  \inline{complex.isPolar}: \inline{Boolean}
\end{equation}

Any statically known expression can be promoted via $inline$. Selection of dynamic fields
on the other hand will return dynamic values despite the fact that record is statically known.
In practice this can be used to specialize a particular execution path in the application to
a particular representation by selectively inlining statically known parts.

Not all type and binding time combinations are correct though. We restrict types
to disallow nesting of more specific binding times into less specific ones.

\begin{figure}
\begin{multicols}{2}
  \infax[\textsc{W-Any}]
  {\wff{\i{Any}}}

  \infrule[\textsc{W-Abs}]
  {i <: j \ \ \ \ i <: k \ \ \ \ \wff{\j{T_1}} \ \ \ \ \wff{\k{T_2}}}
  {\wff{\i{(\j{T_1} \ra \k{T_2})}}}

  \infrule[\textsc{W-TAbs}]
  {i <: j \ \ \ \ i <: k \ \ \ \ \wff{\j{S}} \ \ \ \ \wff{\k{T}}}
  {\wff{\i{([X <: \j{S}] \ra \k{T})}}}

  \infrule[\textsc{W-Rec}]
  {\forall j. \ \ \ \ i <: j \ \ \ \ \seq{\wff{\j{T}}}}
  {\wff{\i{\{\seq{x: \j{T}}\}}}}
\end{multicols}
\caption {Well formed types $\wff{\i{T}}$}
\end{figure}

This restiction allows us to reject programs that have inconsistent annotations.

For example the following function has incorrectly annotated parameter binding time:
\begin{equation}\nonumber
    (x: \inline{Int}) \ra x + 1
\end{equation}

This is inconsistent because the body of the function might not be evaluated at compile-time
(as the function is not inline.) As described in (\textsc{W-Abs}) functions may only have parameters
that are at most as specific as the function binding-time. In our example this doesn't hold as $inline$
is more specific than implicit $static$ annotation on function literal.

\subsection{Subtyping}

Another notable feature of our binding-time analysis system is deep integration with subtyping.
We believe that such integration is crucial for an object-oriented language that wants to
incorporate partial evaluation.

At core of the subtyping relation we have a natural subtyping on binding-time information
with $dynamic$ as top binding-time.

\begin{figure}[H]
\begin{multicols}{2}
  \infax[\textsc{I-Dynamic}]{i <: dynamic}

  \infax[\textsc{I-Static1}]{static <: static}

  \infax[\textsc{I-Static2}]{inline <: static}

  \infax[\textsc{I-Inline}]{inline <: inline}
\end{multicols}
\caption{Binding-time subtyping.}
\end{figure}

We proceed by threading binding time information throughout regular $F_{<:}$ subtyping rules
augmented with standard record types.

\begin{figure}[H]
\begin{multicols}{2}
  \infax[\textsc{S-Top}]
  {\Gamma \ts \i{S} <: Any}

  \infax[\textsc{S-Refl}]
  {\Gamma \ts \i{S} <: \i{S}}

  \infrule[\textsc{S-Trans}]
  {\Gamma \ts \i{S} <: \j{U} \ \ \ \ \Gamma \ts \j{U} <: \k{T}}
  {\Gamma \ts \i{S} <: \j{U}}

  \infrule[\textsc{S-TVar}]
  {X <: \i{T} \in \Gamma}
  {\Gamma \ts X <: \i{T}}

  \infax[\textsc{S-Width}]
  {\{ x_p: i_p T_p\ ^{p \in 1..n+m} \} <: \{ x_p: i_p T_p\ ^{p \in 1..n} \}}

  \infrule[\textsc{S-Arrow}]
  {\Gamma \ts \k{T_1} <: \i{S_1} \ \ \ \ \Gamma \ts \j{S_2} <: \l{T_2}}
  {\Gamma \ts \i{S_1} \ra \j{S_2} <: \k{T_1} \ra \l{T_2}}

  \infrule[\textsc{S-Depth}]
  {\forall p \in 1..n.\ i_p S_p <: j_p T_p}
  {\{ x_p: i_p S_p\ ^{p \in 1..n}\} <: \{ x_p: j_p T_p\ ^{p \in 1..n} \}}

  \infrule[\textsc{S-Inline}]
  {i <: j \ \ \ \ \Gamma \ts S <: T}
  {\Gamma \ts \i{S} <: \j{T}}
\end{multicols}
  \vspace{6pt}
  \infrule[\textsc{S-All}]
  {\Gamma,\ X <: \i{U_1} \ts \j{S_2} <: \k{T_2}}
  {\Gamma \ts [X <: \i{U_1}] \ra \j{S_2} <: [X <: \i{U_1}] \ra \k{T_2}}
  \vspace{6pt}
  \infrule[\textsc{S-Perm}]
  {\{ x_p : i_p S_p\ ^{p \in 1..n}\} $ is permutation of $ \{ y_p: j_p T_p\ ^{p \in 1..n} \}}
  {\{ x_p : i_p S_p\ ^{p \in 1..n}\} <: \{ y_p: j_p T_p\ ^{p \in 1..n} \} }
\caption{Subtyping.}
\end{figure}

Integration between binding-time information and subtyping on regular types is expressed through
(\textsc{S-Inline}) rule that merges the two into one coherent relation.

\subsection{Generics}

Crucial consequence of our design choices made in the system manifests in ability to use
regular generics as means to abstract over binding-time without any additional language constructs.

For example given a generic identity function:
\begin{equation}\nonumber
  identity: \static{([X <: Any] \ra \static{(X \ra X)})} \in \Gamma
\end{equation}

We can instantiate it to both in static and dynamic contexts through corresponding
type application:
\begin{align}\nonumber
  identity[\static{Int}] &: \static{(\static{Int} \ra \static{Int})} \\
  identity[Int]          &: \static{(Int \ra Int)}
\end{align}

In practice this allows us to write code that is polymorphic in the binding time without
any code duplication which is quite common in other partial evaluation systems.

This is possible due to the fact that we've integrated binding time information into types
and augmented subtyping relation with subtyping

\subsection{Typing}

\begin{figure}[H]
\begin{multicols}{2}
  \infrule[\textsc{T-Ident}]
  {x: \i{T} \in \Gamma}
  {\Gamma \ts x: \i{T}}

  \infrule[\textsc{T-Rec}]
  {\forall t. \ \ \ \ \Gamma \ts t: \j{T} \ \ \ \ \wff{\i{\{x: \j{T}\}}}}
  {\Gamma \ts \i{\{ \seq{x = t} \}} : \i{\{\seq{x: \j{T}}\}}}

  \infrule[\textsc{T-App}]
  {\Gamma \ts t_1: \i{(\j{T_1} \ra \k{T_2})} \ \ \ \ \Gamma \ts t_2: \j{T_1}}
  {\Gamma \ts t_1 (t_2) : \k{T_2}}

  \infrule[\textsc{T-Sel}]
  {\Gamma \ts t: \i{\{ x = \j{T_1}, \seq{y = \k{T_2}} \}}}
  {\Gamma \ts t.x : \j{T_1}}

  \infrule[\textsc{T-Inline}]
  {t $ is not literal$ \ \ \ \ \Gamma \ts t: \static{T}}
  {\Gamma \ts \ct{t}: \inline{T}}

  \infrule[\textsc{T-Sub}]
  {\Gamma \ts t: \i{S} \ \ \ \ \Gamma \ts \i{S} <: \j{T}}
  {\Gamma \ts t: \j{T}}
\end{multicols}
  \vspace{4pt}
  \infrule[\textsc{T-Func}]
  {\Gamma,\ x: \j{T_1} \ts t: \k{T_2} \ \ \ \ \wff{\i{(\j{T_1} \ra \k{T_2})}}}
  {\Gamma \ts \i{((x: \j{T_1}) \ra t)} : \i{(\j{T_1} \ra \k{T_2})}}
  \vspace{4pt}
  \infrule[\textsc{T-TAbs}]
  {\Gamma,\ X <: \j{T_1} \ts t_2: \k{T_2} \ \ \ \ \wff{\i{([X <: \j{T_1}] \ra \k{T_2})}}}
  {\Gamma \ts \i([X <: \j{T_1}] \ra t_2): \i{([X <: \j{T_1}] \ra \k{T_2})}}
  \vspace{4pt}
  \infrule[\textsc{T-TApp}]
  {\Gamma \ts t_1: \i{([X <: \j{T_{11}}] \ra \k{T_{12}})}  \ \ \ \ \Gamma \ts \l{T_2} <: \j{T_{11}}}
  {\Gamma \ts t_1[\l{T_2}] : [X \mapsto \l{T_2}] \k{T_{12}}}
\caption{Typing.}
\end{figure}

\subsection{Partial Evaluation}
Assumption is that types are erased and therefore there is no type abstraction or type application and there are no types in lambdas.

\begin{figure}
\begin{multicols}{2}[]

  \infrule[\textsc{PE-Func}]
    {\pe{t}{t'}}
    {\pe{x \ra t}{x \ra t'}}

  \infrule[\textsc{PE-Rec}]
    {\pe{\seq{t}}{\seq{t'}}}
    {\pe{\{ \seq{x = t} \}}{\{ \seq{x = t'} \}}}

  \infrule[\textsc{PE-Inline}]
    {\pe{t}{t'}}
    {\pe{\ct{t}}{{\ct{t'}}}}

  \infrule[\textsc{PE-ISel}]
    {\pe{t}{\ct{\{x = f, \seq{y = f_i}\}}}}
    {\pe{t.x}{f}}

\end{multicols}
\vspace{4pt}

  \infrule[\textsc{PE-Sel}]
    {\pe{t}{t'} \ \ \ t' \neq \ct{\{x = f, \seq{y = f_i}\}}}
    {\pe{t.x}{t'.x}}

  \infrule[\textsc{PE-IApp}]
    {\pe{t_1}{\ct{x \ra b}} \ \ \ \pe{t_2}{t'_2} \ \ \ \pe{[x \rightarrow t'_2] \; b}{b'} }
    {\pe{t_1 (t_2)}{b'}}
  \infrule[\textsc{PE-App}]
    {\pe{t_1}{t'_1} \ \ \ \pe{t_2}{t'_2} \ \ \ t'_1 \neq \ct{x \ra b}}
    {\pe{t_1 (t_2)}{t'_1 (t'_2)}}

\caption{Reduction rules for the partial evaluator.}
\label{fig:partial-evaluation}
\end{figure}

\clearpage
