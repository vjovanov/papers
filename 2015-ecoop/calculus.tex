\clearpage
\section{The \calculus Calculus}
\label{sct:calculus}

\begin{figure}[H]
\begin{multicols}{2}
\syntaxfig{
  S,\ T,\ U ::=                     & \lindent{\mbox{Types:}}              \\
  \gap \i{S} \ra \j{T}              & \mbox{function type}                 \\
  \gap \{ \seq{x: \i{S}} \}         & \mbox{record type}                   \\
  \gap [X <: \i{S}] \ra \j{T}       & \mbox{universal type}                \\
  \gap Any                          & \mbox{top type}                      \\
  \i{T},\ \j{T},\ \k{T},\ \l{T} ::= & \lindent{\mbox{Binding-Time Types:}} \\
  \gap X                            & \mbox{type identifier}               \\
  \gap \dynamic{T}                  & \mbox{dynamic type}                  \\
  \gap \inline{T}                   & \mbox{inline type}                   \\
  \Gamma ::=                        & \lindent{\mbox{Contexts:}}           \\
  \gap \emptyset                    & \mbox{empty context}                 \\
  \gap \Gamma,\ x: \i{T}            & \mbox{term binding}                  \\
  \gap \Gamma,\ X <: \i{T}          & \mbox{type binding}                  \\
}
\syntaxfig{
  t ::=                             & \lindent{\mbox{Terms:}}              \\
  \gap x,\ y                        & \mbox{identifier}                    \\
  \gap v                            & \mbox{dynamic value}                 \\
  \gap \inline{v}                   & \mbox{inline value}                  \\
  \gap \dynamic{t}                  & \mbox{dynamic coercion}              \\
  \gap t(t)                         & \mbox{application}                   \\
  \gap t.x                          & \mbox{selection}                     \\
  \gap t [\i{T}]                    & \mbox{type application}              \\
  v ::=                             & \lindent{\mbox{Values:}}             \\
  \gap (x: \i{T}) \ra t             & \mbox{function value}                \\
  \gap \{ \seq{x = t} \}            & \mbox{record value}                  \\
  \gap [X <: \i{T}] \ra t           & \mbox{type abstraction value}        \\
}
\end{multicols}
\caption{Syntax of \calculus}
\end{figure}

We formalize the essence of our partial evaluation system in a minimalistic calculus
based on kernel \fsub \cite{tapl} with lazy records. To accommodate predictable partial evaluation we
introduce binding-time annotations into the type system as types that
represent two kinds of bindings:

\begin{enumerate}
  \item \textbf{Dynamic binding}. Corresponds to terms that are expected to be evaluted at runtime.
  \item \textbf{Inline binding}. Corresponds to terms that must be evaluated at compile-time.
\end{enumerate}

To simplify judgments in our formalization we use concise $\i{T}$ syntax to abstract over
binding-times of types. Here $i$ signifies the bit of information that says if type is inline
or not and $T$ carries underlying type that is being annotated. So for example in $\inline{Any}$
we get $i = inline$ and $T = Any$.

Similarly we abstract over binding time of terms through $\i{t}$ notation that has analogous
to the one we use for types.

\subsection{Well-formed types}

Even though binding-time information is represented as types, not all
of the possible combinations of types and binding-times is correct.
We restrict types to disallow nesting of more specific binding times
into less specific ones.

\begin{figure}[H]
  \infax[\textsc{W-Any}]
  {\wff{\i{Any}}}

  \infrule[\textsc{W-Abs}]
  {i \leq j \ \ \ \ i \leq k \ \ \ \ \wff{\j{T_1}} \ \ \ \ \wff{\k{T_2}}}
  {\wff{\i{(\j{T_1} \ra \k{T_2})}}}

  \infrule[\textsc{W-TAbs}]
  {i \leq k \ \ \ \ \wff{[X \mapsto \i{S}] \k{T}}}
  {\wff{\i{([X <: \i{S}] \ra \k{T})}}}

  \infrule[\textsc{W-Rec}]
  {i \leq \seq{j} \ \ \ \ \seq{\wff{\j{T}}}}
  {\wff{\i{\{\seq{x: \j{T}}\}}}}
\caption{Well-formed types $\wff{\i{T}}$.}
\end{figure}

We represent notion of more specific binding-times through
a simple partial order on binding time annotations.

\begin{figure}[H]
  \begin{center}
  $ dynamic \leq dynamic $ \\
  $ inline  \leq dynamic $ \\
  $ inline  \leq inline  $
  \end{center}
\caption{Partial order on binding-time $i \leq j$}
\end{figure}

This restiction allows us to reject programs that have inconsistent binding-time annotations.
For example the following function has incorrectly annotated parameter binding time:
\begin{equation}\nonumber
    (x: \inline{Int}) \ra x + 1
\end{equation}

This is inconsistent because a dynamic function may not have any non-dynamic parameters.
As described in \textsc{W-Abs} functions may only have parameters that are at most as specific
as function binding-time. In our example this doesn't hold as $inline$ is more
specific than $dynamic$.

\subsection{Subtyping}

\calculus integrates binding-time annotation into subtyping relation on regular types by
threading inlining information throughout all of the standard subtyping rules.

\begin{figure}[H]
  \infax[\textsc{S-Top}]
  {\Gamma \ts \i{S} <: Any}

  \infax[\textsc{S-Refl}]
  {\Gamma \ts \i{S} <: \i{S}}

  \infrule[\textsc{S-Trans}]
  {\Gamma \ts \i{S} <: \j{U} \ \ \ \ \Gamma \ts \j{U} <: \k{T}}
  {\Gamma \ts \i{S} <: \j{U}}

  \infrule[\textsc{S-Arrow}]
  {\Gamma \ts \k{T_1} <: \i{S_1} \ \ \ \ \Gamma \ts \j{S_2} <: \l{T_2}}
  {\Gamma \ts \i{S_1} \ra \j{S_2} <: \k{T_1} \ra \l{T_2}}

  \infrule[\textsc{S-All}]
  {\Gamma,\ X <: \i{U_1} \ts \j{S_2} <: \k{T_2}}
  {\Gamma \ts [X <: \i{U_1}] \ra \j{S_2} <: [X <: \i{U_1}] \ra \k{T_2}}

  \infrule[\textsc{S-Perm}]
  {\{ x_p : i_p S_p\ ^{p \in 1..n}\} $ is permutation of $ \{ y_p: j_p T_p\ ^{p \in 1..n} \}}
  {\{ x_p : i_p S_p\ ^{p \in 1..n}\} <: \{ y_p: j_p T_p\ ^{p \in 1..n} \} }

  \infrule[\textsc{S-Depth}]
  {\forall p \in 1..n.\ i_p S_p <: j_p T_p}
  {\{ x_p: i_p S_p\ ^{p \in 1..n}\} <: \{ x_p: j_p T_p\ ^{p \in 1..n} \}}

  \infax[\textsc{S-Width}]
  {\{ x_p: i_p T_p\ ^{p \in 1..n+m} \} <: \{ x_p: i_p T_p\ ^{p \in 1..n} \}}
\caption{Subtyping $\Gamma \ts T_1 <: T_2$.}
\end{figure}

Apart from that we also introduce subtyping on binding-time types.

\begin{figure}[H]
  \infrule[\textsc{S-TVar}]
  {X <: \i{T} \in \Gamma}
  {\Gamma \ts X <: \i{T}}

  \infrule[\textsc{S-Inline}]
  {i = j \ \ \ \ \Gamma \ts S <: T}
  {\Gamma \ts \i{S} <: \j{T}}
\caption{Subtyping of binding-time types $\Gamma \ts \i{T_1} <: \j{T_2}$.}
\end{figure}

Two binding-time types are subtypes if their underlying types are
subtypes and if they have the same binding time.

\subsection{Type polymorphism}

Our system retains traditional type abstraction means inherited from \fsub.
We extend it to accomodate encoding of binding-times into types. This allows
us to specify binding type of the abstracted generic type:
\begin{equation}\nonumber
  [T <: \dynamic{Any}] \ra (x: T) \ra x
\end{equation}

For this particular identity function we need to restrict subset of all admissable
types to only allow $dynamic$ ones. Passing an $inline$ type would not make sense
as the resulting type would have not been well-formed.

\subsection{Typing}

\begin{figure}[H]
  \infrule[\textsc{T-Ident}]
  {x: \i{T} \in \Gamma}
  {\Gamma \ts x: \i{T}}

  \infrule[\textsc{T-Rec}]
  {\Gamma \ts \seq{t}: \seq{\j{T}} \ \ \ \ \wff{\i{\{\seq{x: \j{T}}\}}}}
  {\Gamma \ts \i{\{ \seq{x = t} \}} : \i{\{\seq{x: \j{T}}\}}}

  \infrule[\textsc{T-App}]
  {\Gamma \ts t_1: \i{(\j{T_1} \ra \k{T_2})} \ \ \ \ \Gamma \ts t_2: \j{T_1}}
  {\Gamma \ts t_1 (t_2) : \k{T_2}}

  \infrule[\textsc{T-Sel}]
  {\Gamma \ts t: \i{\{ x = \j{T_1}, \seq{y = \k{T_2}} \}}}
  {\Gamma \ts t.x : \j{T_1}}

  \infrule[\textsc{T-Sub}]
  {\Gamma \ts t: \i{S} \ \ \ \ \Gamma \ts \i{S} <: \j{T}}
  {\Gamma \ts t: \j{T}}

  \infrule[\textsc{T-Func}]
  {\Gamma,\ x: \j{T_1} \ts t: \k{T_2} \ \ \ \ \wff{\i{(\j{T_1} \ra \k{T_2})}}}
  {\Gamma \ts \i{((x: \j{T_1}) \ra t)} : \i{(\j{T_1} \ra \k{T_2})}}

  \infrule[\textsc{T-TAbs}]
  {\Gamma,\ X <: \j{T_1} \ts t_2: \k{T_2} \ \ \ \ \wff{\i{([X <: \j{T_1}] \ra \k{T_2})}}}
  {\Gamma \ts \i([X <: \j{T_1}] \ra t_2): \i{([X <: T_1] \ra \k{T_2})}}

  \infrule[\textsc{T-TApp}]
  {\Gamma \ts t: \i{([X <: T_1] \ra \k{T_2})}  \ \ \ \ \Gamma \ts T <: T_1}
  {\Gamma \ts t[T] : [X \mapsto T] \k{T_2}}

  \infrule[\textsc{T-Dynamic}]
  {\Gamma \ts t: \inline{T}}
  {\Gamma \ts \dynamic{t} : \dynamic{T}}
\caption{Typing $\Gamma \ts t: \i{T}$.}
\end{figure}

Similarly to the changes made to the subtyping relation we thread binding-time information
throughout typing relation. Apart from that we also ensure that all literals produces by the
user have well-formed types.

\subsection{Partial Evaluation}

\begin{figure}[H]
  \infrule[\textsc{PE-Func}]
  {t \pe t'}
  {(x: \i{T}) \ra t \pe (x: T) \ra t'}

  \infrule[\textsc{PE-Rec}]
  {\seq{t} \pe \seq{t'}}
  {\{\seq{x = t}\} \pe \{\seq{x = t'}\}}

  \infrule[\textsc{PE-TAbs}]
  {t \pe t'}
  {[X <: \i{T}] \ra t \pe [X <: \i{T}] \ra t'}

  \infrule[\textsc{PE-App}]
  {t_1 \pe t_1' \ \ \ \ t_1 \ne \inline{t_3} \ \ \ \ t_2 \pe t_2'}
  {t_1(t_2) \pe t_1'(t_2')}

  \infrule[\textsc{PE-Sel}]
  {t \pe t' \ \ \ \ t' \ne \inline{t_3}}
  {t.x \pe t'.x}

  \infrule[\textsc{PE-TApp}]
  {t_1 \pe t_1' \ \ \ \ t_1' \ne \inline{t_3}}
  {t_1[T_1] \pe t_2'}

  \infrule[\textsc{PE-InlineApp}]
  {t_1 \pe \inline{(x: \i{T}) \ra t} \ \ \ \ t_2 \pe t_2' \ \ \ \ [x \mapsto t_2'] t \pe t'}
  {t_1(t_2) \pe t'}

  \infrule[\textsc{PE-InlineSel}]
  {t \pe \inline{\{x = t_x,\ \seq{y = t_y}\}} \ \ \ \ t_x \pe t_x'}
  {t.x \pe t_x'}

  \infrule[\textsc{PE-InlineTApp}]
  {t_1 \pe \inline [X <: \i{T_2}] \ra t_2 \ \ \ \ [X \mapsto \i{T_1}] t_2 \pe t_2'}
  {t_1[\i{T_1}] \pe t_2'}

  \infax[\textsc{PE-InlineValue}]
  {\inline{v} \pe \inline{v}}

  \infrule[\textsc{PE-Dynamic}]
  {t \pe \inline{t'}}
  {\dynamic{t} \pe t'}
\caption{Partial evaluation $t \pe t'$}
\label{fig:partial-evaluation}
\end{figure}

\subsection{Evaluation}

Once partial evaluation is complete we strip all binding-time annotations on types
and convert inline terms into corresponding dynamic ones. After that we can use
standard \fsub evaluation rules augmented with lazy records semantics (\textsc{E-Sel}).

\begin{figure}[H]
  \infax[\textsc{E-Value}]
  {v \e v}

  \infrule[\textsc{E-App}]
  {t_1 \e (x: T) \ra t \ \ \ \ t_2 \e v \ \ \ \ [x \mapsto v] t \e v'}
  {t_1(t_2) \e v'}

  \infrule[\textsc{E-TApp}]
  {t_1 \e [X <: T_2] \ra t_2 \ \ \ \ [X \mapsto T_1] t_2 \e v}
  {t_1[T_1] \e v}

  \infrule[\textsc{E-Sel}]
  {t \e \{ x = t_x,\ \seq{y = t_y}\} \ \ \ \ t_x \e v}
  {t.x \e v}
\caption{Evaluation $t \e v$}
\end{figure}

\subsection{Conjectures}

\begin{enumerate}
  \item Progress and preservation of partial evaluation.
  \item Progress and preservation of evaluation.
\end{enumerate}
