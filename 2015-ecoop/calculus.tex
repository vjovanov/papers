\clearpage
\section{Formalization $F_{i <:}$}

\begin{figure}
\begin{multicols}{2}
\syntaxfig{
  t ::=                             & \lindent{\mbox{Terms:}}            \\
  \gap x, y                         & \mbox{identifier}                  \\
  \gap (x: \i{T}) \ra t             & \mbox{function}                    \\
  \gap t(t)                         & \mbox{application}                 \\
  \gap \{ \seq{x = t} \}            & \mbox{record}                      \\
  \gap t.x                          & \mbox{selection}                   \\
  \gap \ct t                        & \mbox{inlining request}            \\
  \gap [X <: \i{T}] \ra t           & \mbox{type abstraction}            \\
  \gap t [\i{T}]                    & \mbox{type application}            \\
  \Gamma ::=                        & \lindent{\mbox{Contexts:}}         \\
  \gap \emptyset                    & \mbox{empty context}               \\
  \gap \Gamma,\ x: iT               & \mbox{term binding}                \\
  \gap \Gamma,\ X <: iT             & \mbox{type binding}                \\
}
\syntaxfig{
  S,\ T,\ U ::=                     & \lindent{\mbox{Types:}}            \\
  \gap \i{S} \ra \j{T}              & \mbox{function type}               \\
  \gap \{ \seq{x: \i{S}} \}         & \mbox{record type}                 \\
  \gap [X <: \i{S}] \ra \j{T}       & \mbox{universal type}              \\
  \gap Any                          & \mbox{top type}                    \\
  \i{T},\ \j{T},\ \k{T},\ \l{T} ::= & \lindent{\mbox{Inlineable Types:}} \\ 
  \gap X                            & \mbox{type identifier}             \\
  \gap T,\ \dynamic{T}              & \mbox{dynamic type}                \\
  \gap \static{T}                   & \mbox{static type}                 \\
  \gap \inline{T}                   & \mbox{must inline type}            \\
}
\end{multicols}
\caption{Syntax of $F_{i<:}$}
\end{figure}

We formalize the essence of our inlining system in a minimalistic calculus based 
on $F_{<:}$ with records. To accomodate inlining we introduce binding-time annotations 
into the type system as first-class type production rules that represent three kinds 
of bindings:

\begin{enumerate}
  \item \textbf{Dynamic binding}. These are the types which express computation at runtime.
        All types written in the end user code are considered to be dynamic by default if
        no other binding-time annotation is given.

  \item \textbf{Static binding}. Values of static terms can be computed at compile-time
        (\eg constant expressions) but at are still evaluated at runtime by default.
        All language literals are static by default (\textsc{T-Rec}, \textsc{T-Func}).

  \item \textbf{Inline binding}. And finally the types that correspond to terms that
        are hinted to be computed at compile-time whenever possible. 
\end{enumerate}

\subsection{Composition}

Our system exposes binding times as first-class types making it easy to compose and reason about.
An interesting consequence of this is that we can represent values which are partially static
and partially dynamic.

For example lets have a look at simple record that describes a complex number with
two possible representations encoded through $isPolar$ flag:

\begin{equation}\nonumber
    complex: \static{\{ isPolar: \static{Boolean},\ a: Double,\ b: Double \}} \in \Gamma
\end{equation}

This type is constructed out of a number of components with varying binding times.
Representation encoding is known in advance and is static according to the signature.  
Coordinates $a$ and $b$ do not have any binding-time annotation meaning that they are 
dynamic.

Given this binding to $complex$ in our environment $\Gamma$ we can use $inline$ to obtain
a compile-time view to access $isPolar$ field:
\begin{equation}\nonumber
  \inline{complex.isPolar}: \inline{Boolean}
\end{equation}

Any statically known expression can be promoted to become $inline$ that would force its computation
to happen at compile-time. Selection of dynamic fields on the other hand will return dynamic values despite 
the fact that record is statically known. It's also not possible to access them at compile-time as 
compile-time computations can only work with $inline$ values.

Not all type and binding time combinations are correct though. We restrict possible combinations of 
to disallow nesting of more specific binding time into less specific one.

\begin{figure}
\begin{multicols}{2}
  \infax[\textsc{W-Any}]
  {\wff{\i{Any}}}

  \infrule[\textsc{W-Abs}]
  {i <: j \ \ \ \ i <: k \ \ \ \ \wff{\j{T_1}} \ \ \ \ \wff{\k{T_2}}}
  {\wff{\i{(\j{T_1} \ra \k{T_2})}}}

  \infrule[\textsc{W-TAbs}]
  {i <: j \ \ \ \ i <: k \ \ \ \ \wff{\j{S}} \ \ \ \ \wff{\k{T}}}
  {\wff{\i{([X <: \j{S}] \ra \k{T})}}}

  \infrule[\textsc{W-Rec}]
  {\forall j. \ \ \ \ i <: j \ \ \ \ \seq{\wff{\j{T}}}}
  {\wff{\i{\{\seq{x: \j{T}}\}}}}
\end{multicols}
\caption {Well formed types $\wff{\i{T}}$}
\end{figure}

This restiction allows us to reject programs that have inconsistent binding-time annotations. 

\subsection{Subtyping}

Another notable feature of our binding-time analysis system is deep integration with subtyping. 
We believe that such integration is crucial for an object-oriented language that wants to 
incorporate binding-time analysis.

At core of the subtyping relation we have a natural subtyping on binding-time information
with as $dynamic$ as top binding-time.

\begin{figure}[H]
\begin{multicols}{2}
  \infax[\textsc{I-Dynamic}]{\Gamma \ts i <: dynamic}

  \infax[\textsc{I-Static1}]{\Gamma \ts static <: static}

  \infax[\textsc{I-Static2}]{\Gamma \ts inline <: static}

  \infax[\textsc{I-Inline}]{\Gamma \ts inline <: inline}

  \infrule[\textsc{I-Ident}]
  {X <: \j{T} \in \Gamma \ \ \ \ \Gamma \ts i <: j}
  {\Gamma \ts i <: X}
\end{multicols}
\caption{Binding-time subtyping.}
\end{figure}

We proceed by threading binding time information thrughout regular $F_{<:}$ subtyping rules
augmented with standard record types.

\begin{figure}[H]
\begin{multicols}{2}
  \infax[\textsc{S-Top}]
  {\Gamma \ts \i{S} <: Any}

  \infax[\textsc{S-Refl}]
  {\Gamma \ts \i{S} <: \i{S}}

  \infrule[\textsc{S-Trans}]
  {\Gamma \ts \i{S} <: \j{U} \ \ \ \ \Gamma \ts \j{U} <: \k{T}}
  {\Gamma \ts \i{S} <: \j{U}}

  \infrule[\textsc{S-TVar}]
  {X <: \i{T} \in \Gamma}
  {\Gamma \ts X <: \i{T}}

  \infax[\textsc{S-Width}]
  {\{ x_p: i_p T_p\ ^{p \in 1..n+m} \} <: \{ x_p: i_p T_p\ ^{p \in 1..n} \}}

  \infrule[\textsc{S-Arrow}]
  {\Gamma \ts \k{T_1} <: \i{S_1} \ \ \ \ \Gamma \ts \j{S_2} <: \l{T_2}}
  {\Gamma \ts \i{S_1} \ra \j{S_2} <: \k{T_1} \ra \l{T_2}}

  \infrule[\textsc{S-Depth}]
  {\forall p \in 1..n.\ i_p S_p <: j_p T_p}
  {\{ x_p: i_p S_p\ ^{p \in 1..n}\} <: \{ x_p: j_p T_p\ ^{p \in 1..n} \}}

  \infrule[\textsc{S-Inline}]
  {i <: j \ \ \ \ \Gamma \ts S <: T}
  {\Gamma \ts \i{S} <: \j{T}}
\end{multicols}
  \vspace{6pt}
  \infrule[\textsc{S-All}]
  {\Gamma,\ X <: \i{U_1} \ts \j{S_2} <: \k{T_2}}
  {\Gamma \ts [X <: \i{U_1}] \ra \j{S_2} <: [X <: \i{U_1}] \ra \k{T_2}}
  \vspace{6pt}
  \infrule[\textsc{S-Perm}]
  {\{ x_p : i_p S_p\ ^{p \in 1..n}\} $ is permutation of $ \{ y_p: j_p T_p\ ^{p \in 1..n} \}}
  {\{ x_p : i_p S_p\ ^{p \in 1..n}\} <: \{ y_p: j_p T_p\ ^{p \in 1..n} \} }
\caption{Subtyping.}
\end{figure}

Integration between binding-time information and subtyping on regular types is expressed through
(\textsc{S-Inline}) rule that merges the two into one coherent relation.

\subsection{Generics}

\begin{figure}
\begin{multicols}{2}
  \infrule[\textsc{T-Ident}]
  {x: \i{T} \in \Gamma}
  {\Gamma \ts x: \i{T}}

  \infrule[\textsc{T-Rec}]
  {\forall t. \ \ \ \ \Gamma \ts t: \j{T} \ \ \ \ \wff{\i{\{x: \j{T}\}}}}
  {\Gamma \ts \i{\{ \seq{x = t} \}} : \i{\{\seq{x: \j{T}}\}}}

  \infrule[\textsc{T-App}]
  {\Gamma \ts t_1: \i{(\j{T_1} \ra \k{T_2})} \ \ \ \ \Gamma \ts t_2: \j{T_2}}
  {\Gamma \ts t_1 (t_2) : \k{T_2}}

  \infrule[\textsc{T-Sel}]
  {\Gamma \ts t: \i{\{ x = \j{T_1}, \seq{y = \k{T_2}} \}}}
  {\Gamma \ts t.x : \j{T_1}}

  \infrule[\textsc{T-Inline}]
  {t $ is not literal$ \ \ \ \ \Gamma \ts t: \static{T}}
  {\Gamma \ts \ct{t}: \inline{T}}

  \infrule[\textsc{T-Sub}]
  {\Gamma \ts t: \i{S} \ \ \ \ \Gamma \ts \i{S} <: \j{T}}
  {\Gamma \ts t: \j{T}}
\end{multicols}
  \vspace{4pt}
  \infrule[\textsc{T-Func}]
  {\Gamma,\ x: \j{T_1} \ts t: \k{T_2} \ \ \ \ \wff{\i{(\j{T_1} \ra \k{T_2})}}}
  {\Gamma \ts \i{((x: \j{T_1}) \ra t)} : \i{(\j{T_1} \ra \k{T_2})}}
  \vspace{4pt}
  \infrule[\textsc{T-TAbs}]
  {\Gamma,\ X <: \j{T_1} \ts t_2: \k{T_2} \ \ \ \ \wff{\i{([X <: \j{T_1}] \ra \k{T_2})}}}
  {\Gamma \ts \i([X <: \j{T_1}] \ra t_2): \i{([X <: \j{T_1}] \ra \k{T_2})}}
  \vspace{4pt}
  \infrule[\textsc{T-TApp}]
  {\Gamma \ts t_1: \i{([X <: \j{T_{11}}] \ra \k{T_{12}})}  \ \ \ \ \Gamma \ts \l{T_2} <: \j{T_{11}}} 
  {\Gamma \ts t_1[\l{T_2}] : [X \mapsto \l{T_2}] \k{T_{12}}}
\caption{Typing.}
\end{figure}

\clearpage
