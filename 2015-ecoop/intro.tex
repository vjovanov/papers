\section{Introduction}
\label{sct:introduction}

\emph{Partial evaluation}~\cite{jones1993partial} is an optimization technique
that identifies \emph{statically known} program parts and pre-computes them at
compile time. The compile-time computation yields a \emph{residual program} that
does not contain the, previously identified, statically known parts of the
program.  Partial evaluation has been intensively studied and successfully
applied for: removing abstraction overheads in high-level
programs~\cite{carette2005multi,rompf2012lightweight}, domain-specific
languages~\cite{brady2010,jonnalagedda2014staged}, and converting language
interpreters into compilers~\cite{futamura1999partial,lancet,wurthinger2013one}.
Applying partial evaluation in these domains often improves program performance
by several orders of magnitude~\cite{shali2011Hybrid,brady2010}.

Unlike other compiler optimizations partial evaluation is not \emph{safe} as it
 might lead to \emph{code explosion} and might not \emph{terminate}. Due to
 compile-time execution,  computing \code{fold}s and loops over data structures
 of static size can produce arbitrarily  large programs. Furthermore, in a
 Turing-complete language assuring termination is undecidable.

Automatically assuring safety of partial evaluators necessarily leads to
 lack of \emph{predictability}. To illustrate, let us define a function
 \code{dot} for computing a dot-product of two vectors that contain numeric values
 \footnotetext{We use Scala for all code examples in this paper. In order to
 comprehend the paper the reader is required to know the mere basics of the
 language}.

\vspace{1.8mm}
\begin{listing}
  def dot[V:Numeric](v1: Vector[V], v2: Vector[V]): V =
    (v1 zip v2).foldLeft(zero[V]){ case (prod, (cl, cr)) =>
      prod + cl * cr
    }
\end{listing}
\vspace{1.8mm}

When \code{dot} is called with vectors of static size (\eg \code{dot(Vector(2,
 4), Vector(1, 10))}) the abstraction overhead of \code{zip} and \code{foldLeft}
 can be completely removed. However, the partial evaluator must apply extensive
 analysis to conclude that vectors are static in size and that this can be later
 used to unroll the recursion inside \code{foldLeft}. Even if the analysis is
 successful the evaluator must be conservative about unrolling the
 \code{foldLeft}. The vector sizes, and thus the produced code, can unacceptably
 large in a general case. What if we know that vector sizes are relatively small
 and we would like to predictably unroll \code{dot}  into a flat sum of products?


Lack of predictability and danger of code explosion are the reason that
 successful partial evaluators
 \cite{brady2010,taha_multi-stage_1997,rompf2012lightweight,wurthinger2013one,le2004specialization}
  are programmer controlled. We categorize the existing solutions in three categories
 (for further discussion \cf \sct{sct:related-work}):

\begin{itemize}
 \item Programming languages Idris and D provide allow placing the \code{static}
  annotation on function arguments. Since \code{static} is placed on terms, it
  denotes that the \emph{whole term} is static. This restricts the number of programs
  that can be expressed, \eg, we could not express in the signature of \emph{dot} that
  vector parameters are static in size.

 \item Type-directed partial evaluation~\cite{danvy1999type} and
  Lightweight Modular Staging~\cite{rompf2012lightweight} use types to communicate
  the programmer's intent about partial evaluation. By changing the types of parameters
  to be (\eg \code{Vector[Rep[T]]) these approaches can express that parameter vectors
  are statically known.However, they still require existence of two data structures
  (\eg \code{Rep[Vector]} and \code{Vector}. This fosters, costly and hardly maintainable, code duplication.

 \item MetaOCaml~\cite{taha_multi-stage_1997} places terms in, possibly nested,
   quotes. Depth of the term in the quotes denotes the stage of the computation
   where it will be executed. In MetaOCaml we can express the \code{dot} function,
   but we have to modify the code of the \code{dot} function which might not be desirable.
\end{itemize}


% To show how programmers can control partial evaluation we

Ideally, a programmer would with a minimal number of annotations be able to:
 \emph{i)} require that input vectors are of statically known size but polymorphic
  in their elements, \emph{ii)} without modifying the terms require that all operations
  on vector arguments are further partially evaluated, \emph{iii)} allow elements
  of vectors to be generic, and \emph{iv)} reuse the existing implementation of
  the \code{Vector} data structure.

The main idea of this paper is to explicitly capture the user's intent about partial
evaluation in the types. We annotate every type in the language with one of the three values:
\begin{itemize}
 \item $dynamic$ signifies that the value of the type is not known at compile-time. In code $dynamic$ is represented as \code{@d}.
 \item $static$ signifies that the value is known at compile-time. In code $static$ is represented as \code{@s}.
 \item $inline$ requires that the type is statically known and guarantees that operations on the term will be partially evaluated. In code $inline$ is represented as \code{@i}.
\end{itemize}

With our partial evaluator, to require that vectors \code{v1} and \code{v2} are static and
to partially evaluate the function, a programmer would need to make a simple modification of
the \code{dot} signature:
\vspace{1.8mm}
\begin{listing}
  def dot[V: Numeric](v1: Vector[V] @i, v2: Vector[V] @i): V
\end{listing}
\vspace{1.8mm}
This, in effect, requires that only vector arguments (not their elements) are statically known and that all operations will be inlined and further partially evaluated. Residual programs of \code{dot} application in different cases are:

\vspace{1.8mm}
\begin{listing}[mathescape]
  // [el1, el2, el3, el4] are dynamic
  dot(Vector(el1, el2), Vector(el3, el4))
    $\hookrightarrow$ el1 * el3 + el2 * el4

  dot(Vector(2, 4), Vector(1, 10))
    $\hookrightarrow$ 2 * 1 + 4 * 10

  // inline promotes static terms into inline
  dot(Vector(inline(2), inline(4)), Vector(inline(1), inline(10)))
    $\hookrightarrow$ 42
\end{listing}
\vspace{1.8mm}

Contributions:

Evaluation:

Sections:
